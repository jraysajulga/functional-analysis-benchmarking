---
title: "Top N"
author: "Caleb Easterly"
date: "April 26, 2018"
output:
  html_document: default
  word_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The goal here is to estimate the top *n* 'things' that are changing across WS and NS, by fold change. The fold change is calculated by the sum of the spectral counts attributed to each 'thing' - in eggNOG mapper and BLAST, the counts are aggregated by protein; in MEGAN, they are aggregated by eggNOG orthologous group; and in metaGOmics and Unipept, they are assigned to GO terms. In all cases, the Laplace correction is made, which is just adding 1 to all observed counts. This prevents division by zero, and allows for fold change estimation when one 'thing' was seen in one sample but not in another. 

# Reading in data
Necessary packages:
```{r message=FALSE}
library(GO.db)
library(data.table)
library(dplyr)
library(kableExtra)
library(stringr)
library(networkD3)
library(tidyverse)
```

## Peptides

These are the counts used in eggNOG-mapper and BLAST results interpretation. 

```{r}
peptidesNS <- read.delim("peptide_shaker_outputs/737NS_Peptide_Shaker_Peptide_Report.tabular",
                         stringsAsFactors = FALSE) %>%
    select(peptide = Sequence, countNS = "X.Validated.PSMs")

peptidesWS <- read.delim("peptide_shaker_outputs/737WS_Peptide_Shaker_Peptide_Report.tabular",
                         stringsAsFactors = FALSE) %>%
    select(peptide = Sequence, countWS = "X.Validated.PSMs") 

peptides_all <- full_join(peptidesNS, peptidesWS, by = "peptide")
peptides_all[is.na(peptides_all)] <- 0
```

## eggNOG mapper results

Join peptides to counts, and calculate ratios.

```{r}
eggnog <- read.delim("eggnogmap_results/diamond_annotations.tabular",
                     stringsAsFactors = FALSE,
                     header = FALSE) %>% 
    select(peptide = V1, protein = V2, gene = V5, go = V6, ko = V7, desc = V13)
eggnog
eggnog_w_counts <- left_join(eggnog,
                             peptides_all,
                             by = "peptide") %>%
    group_by(protein, desc, gene, go) %>%
    summarize(sumCountWS = sum(countWS) + 1, sumCountNS = sum(countNS) + 1) %>%
    mutate(log2ratio = log2(sumCountWS/sumCountNS)) %>%
    arrange(-log2ratio) %>%
    select(protein, go, gene, sumCountWS, sumCountNS, log2ratio, desc)
eggnog_w_counts$name <- sapply(strsplit(eggnog_w_counts$go, ","), function ( x ) { paste(Term(x), collapse="; ")})
```


Top *N*:
```{r echo=FALSE, results='asis'}
library(knitr)
n <- 100
kable(head(eggnog_w_counts, n), caption = paste("eggNOG-mapper: top", n, "fold changes"))
```

The <a href="http://pfam.xfam.org/family/PF05658">Pfam:YadA</a> refers to the YadA head domain in the trimeric autotransporter adhesin protein family. 

## Blast
```{r}
blast <- read.delim('blast_results/blastp_vs_nr_current.tabular',
                    stringsAsFactors = FALSE,
                    header = FALSE) %>%
    select(peptide = V1, protein = V2, desc = V25)

blast_counts <- left_join(blast, peptides_all, by = "peptide") %>%
    group_by(protein, desc) %>%
    filter(!is.na(countWS) & !is.na(countNS)) %>%
    summarize(sumCountWS = sum(countWS) + 1, sumCountNS = sum(countNS) + 1) %>%
    mutate(log2ratio = log2(sumCountWS/sumCountNS)) %>%
    arrange(-log2ratio)
```

Print results:
```{r echo=FALSE, results='asis'}
kable(head(blast_counts, n), caption = paste("BLAST: Top ", n, " fold changes"))
```

## metaGOmics

We take the top *n* results that have a FDR-corrected $q$ value less than 0.05. 

```{r}
metagomics <- read.delim("metaGOmics_results/go_compare_149_150.txt",
                         comment.char = "#") %>%
    select(go = GO.acc,
           name = GO.name,
           log2ratio =  Laplace.corr..Log.2..fold.change,
           p = Laplace.corr..q.value)

metagomics_filt <- metagomics %>% filter(p < 0.05) %>%
    arrange(-log2ratio)
```

Top *n* results:
```{r echo=FALSE, results='asis'}
kable(head(metagomics_filt, n), caption = paste("MetaGOmics: Top", n, "fold changes"))
```

## MEGAN

```{r}
megan <- read.delim("MEGAN_outputs/737NSvsWS_EGGNOGcount.csv") %>%
    select(og = X.Datasets, countNS = X737_NS_BLASTOutput_2StepCombined,
           countWS = X737_WS_BLASTOutput_2StepCombined) %>%
    mutate(corrWS = countWS + 1,
           corrNS = countNS + 1,
           log2ratio = log2(corrWS/corrNS)) %>%
    arrange(-log2ratio)
megan_go <- read.delim("MEGAN_outputs/go_terms.txt",
                        header = TRUE,
                        stringsAsFactors = FALSE)
# Double check that GO terms are in order (randomly check ten times for parity)
sapply(sample(1:nrow(megan), 10, replace=T), function ( n ) {
    grepl(megan_go[n, "og"], megan[n, "og"])
})
megan$name <- sapply(strsplit(megan_go$go, ","), function ( x ) { paste(Term(x), collapse="; ")})
```

Top *n* results:
```{r echo=FALSE, results='asis'}
kable(head(megan, n), caption = paste("MEGAN: Top", n, "fold changes"))
```

Note that <a href="https://enzyme.expasy.org/EC/3.2.1.52">EC 3.2.1.52</a> is a beta-hexosaminidase and <a href="http://eggnogdb.embl.de/#/app/results?target_nogs=ENOG410YESU">ENOG410YESU</a> is involved in cell wall/membrane/envelope biogenesis.

## Unipept

```{r}
unipept_results_NS <- paste('unipept_results/',
                               list.files("unipept_results/", pattern = "^737NS.*\\.csv"),
                               sep = "")
unipept_results_WS <- paste('unipept_results/',
                               list.files("unipept_results/", pattern = "^737WS.*\\.csv"),
                               sep = "")
unipeptNS <- lapply(unipept_results_NS, function(i) {
        read.delim(i, sep = ',', as.is = TRUE)}) %>%
    bind_rows() %>%
    select(-X) %>%
    rename(peptides = X.peptides)
unipeptWS <- lapply(unipept_results_WS, function(i) {
    read.delim(i, sep = ',', as.is = TRUE)}) %>%
    bind_rows() %>%
    select(-X) %>%
    rename(peptides = X.peptides)

unipept_all <- inner_join(unipeptNS, unipeptWS, by = c("GO.term", "Name")) %>%
    mutate(lapCountNS = peptides.x + 1, lapCountWS = peptides.y + 1,
           log2ratio = log2(lapCountWS/lapCountNS)) %>%
    select(GO.term, Name, lapCountWS, lapCountNS, log2ratio) %>%
    arrange(-log2ratio)
```

Top *n*:
```{r echo=FALSE, results='asis'}
kable(head(unipept_all, n), caption = paste("Unipept: top", n, "Fold Changes"))
```


## MetaProteomeAnalyzer

```{r}
ns_files <- list.files('mpa_results/NS', pattern = "_proteins.csv", full.names = TRUE)
pNS <- bind_rows(lapply(ns_files, function(i) read.delim(i, stringsAsFactors = FALSE))) %>%
    group_by(Protein.Accession, Protein.Description) %>%
    summarize("SpecCount" = sum(Spectral.Count))
ws_files <- list.files('mpa_results/WS', pattern = "_proteins.csv", full.names = TRUE)
pWS <- bind_rows(lapply(ws_files, function(i) read.delim(i, stringsAsFactors = FALSE))) %>%
    group_by(Protein.Accession, Protein.Description) %>%
    summarize("SpecCount" = sum(Spectral.Count))

pAll <- full_join(pNS, pWS, by=c("Protein.Accession", "Protein.Description")) %>%
    mutate(nsCount = SpecCount.x + 1, wsCount = SpecCount.y + 1,
           log2ratio = log2(wsCount/nsCount)) %>%
    arrange(-log2ratio)
pAll$name <- as.character(sapply(pAll$Protein.Accession, function ( protid ) {
    goids <- mpa_uniprot[mpa_uniprot$Entry == protid,]$Gene.ontology.IDs
    sapply(strsplit(goids, "; "), function ( x ) { paste(Term(x), collapse="; ")})
}))
```

Top *n*:
```{r echo=FALSE, results='asis'}
kable(head(pAll, n), caption = paste("MetaProteomeAnalyzer: top", n, "Fold Changes"))
```

## Prophane

```{r}
prophane_WS <- read.delim("prophane_results/summary_WS.txt", sep = "\t",
                          stringsAsFactors = FALSE) %>% select(members_identifier,
                                                               ws = quant..sample_737..mean.,
                                                               ws_go1 = task_6..fun_from_TIGRFAMs_15_cut_tc..tigrfam2GO,
                                                               ws_go2 = task_7..fun_from_PFAMs_32..pfam2GO,
                                                               ws_go3 = task_8..fun_from_eggNog_4.5.1..og2GO)
prophane_NS <- read.delim("prophane_results/summary_NS.txt", sep = "\t",
                          stringsAsFactors = FALSE) %>% select(members_identifier,
                                                               ns = quant..sample_737..mean.,
                                                               ns_go1 = task_6..fun_from_TIGRFAMs_15_cut_tc..tigrfam2GO,
                                                               ns_go2 = task_7..fun_from_PFAMs_32..pfam2GO,
                                                               ns_go3 = task_8..fun_from_eggNog_4.5.1..og2GO)
prophane <- data.table(inner_join(prophane_NS, prophane_WS, by = c("members_identifier")) %>%
    filter(ns != "-", ws != "-") %>%
    mutate(fc = log2(as.double(ws)/as.double(ns)),
           gos = gsub(" ","", paste(ns_go1, ws_go1, ns_go2, ws_go2, ns_go3, ws_go3, sep=","))) %>%
    filter(gos != "") %>%
    arrange(-fc) %>%
    select(fc, gos, ns_go1, ws_go1, ns_go2, ws_go2, ns_go3, ws_go3))
prophane$gos <- sapply(strsplit(prophane$gos,","), function(x) {paste(unique(x[x != "-"]), collapse = ",")})
prophane <- prophane[ , list( gos = unlist( strsplit( gos , "," ) ) ) , by = fc ]
prophane$names <- Term(prophane$gos)
prophane <- prophane %>% group_by_at(vars(fc)) %>%
    summarize_all(paste, collapse="; ")
```


## Unipept and MetaGOmics

This is comparing the estimated fold changes for GO terms for the two tools that natively use GO terms, Unipept and MetaGOmics. 

```{r}
um <- inner_join(unipept_all, metagomics, by = c("GO.term" = "go"))
png("um_cor.png", res = 700, width = 4, height = 4, units = "in")
plot(log2ratio.x ~ log2ratio.y, data = um, pch = 20, cex = 0.3,
     xlab = "Unipept: Log2 Ratio",
     ylab = "MetaGOmics: Log2 Ratio")
mod <- lm(log2ratio.x ~ log2ratio.y, data = um)
abline(0, 1, col = "red", lty = 2)
abline(coef(mod))
grid()
dev.off()
cor.test(um$log2ratio.x, um$log2ratio.y,
         method = "pearson", alternative = "two.sided")
```

### Rank comparison

How do metaGOmics and Unipept rankings compare? 

```{r}
top5_meta <- metagomics_filt$go[1:5]
m2u_ranks <- rep(0, 5)
u2m_ranks <- rep(0, 5)
top5_uni <- unipept_all$GO.term[1:5]
for (i in 1:5){
    m2u_rank <- which(unipept_all$GO.term == top5_meta[i])
    u2m_rank <- which(metagomics_filt$go == top5_uni[i])
    m2u_ranks[i] <- ifelse(length(m2u_rank) == 1, m2u_rank, NA)
    u2m_ranks[i] <- ifelse(length(u2m_rank) == 1, u2m_rank, NA)
}

m2u <- data.frame("go_term" = top5_meta,
                  "rank_in_metagomics" = 1:5,
                  "rank_in_unipept" = m2u_ranks)

u2m <- data.frame("go_term" = top5_uni,
                  "rank_in_unipept" = 1:5,
                  "rank_in_metagomics" = u2m_ranks)

```

### How Unipept Ranks MetaGOmics' top 5
```{r echo=FALSE, results='asis'}
kable(m2u)
```

### How MetaGOmics ranks Unipept's top 5
```{r echo=FALSE, results='asis'}
kable(u2m)
```

## Top n Table
```{r}
rank_table <- data.frame(eggNOG = head(eggnog_w_counts$desc, n),
                          MEGAN = head(megan$og, n),
                     metaGOmics = head(metagomics_filt$name, n),
                            MPA = head(pAll$Protein.Description, n),
                        Unipept = head(unipept_all$Name, n),
                       Prophane = head(prophane$names, n))

# Remove extra text
rank_table$MPA <- sapply(rank_table$MPA, function( x ) { gsub('[A-Z0-9_]+ (.+) OS.+','\\1', x) })
rank_table$MEGAN <-sapply(rank_table$MEGAN, function( x ) { gsub('[A-Z0-9]+ (.+)','\\1', x) })

write.table(rank_table, "top100.tabular", sep="\t", quote = TRUE)
```

## Let's look at how the top terms are ranked in other tools

### Top Unipept terms
```{r}
getMatch <- function(gos1, gos2){
    delimiter <- "; "
    if (grepl(",",gos1) || grepl(",", gos2)){
        delimiter <- ","
    }
    gos1 <- unique(unlist(strsplit(as.character(gos1), delimiter)))
    gos2 <- unique(unlist(strsplit(as.character(gos2), delimiter)))
    gos1 <- gos1[gos1 != "NA"]
    gos2 <- gos2[gos2 != "NA"]
    matched <- sapply(gos1, function ( go1 ) { 
        if(go1 %in% gos2){ go1 }
    })
    paste(unlist(matched), collapse="; ")
}

getMatches <- function(col_gos1, col_gos2, name){
    paths <- data.frame(source = character(),
                        target = character(),
                        group = character(),
                        value = numeric())
    nodes <- sapply(1:20, function ( x ) { paste(rep(" ", x), collapse="") })
    
    matches <- as.data.frame(unlist(sapply(col_gos1, function ( gos1 ){
        ranks <- lapply(col_gos2, function ( gos2){
            getMatch(gos1, gos2)
        })
        rank_list <- which(ranks != "")
        top_list <- rank_list[as.numeric(rank_list) <= 10]
        
        # Set up nodes and paths from top 10 matches
        if (length(top_list) != 0){
            nodes[top_list] <<- as.character(top_list)
            path <- data.frame(target = as.character(top_list)) %>%
                mutate(source = gos1,
                       value = 0.01,
                       group = name) %>%
                select(source, target, value, group)
            paths <<- rbind(paths, path)
        }
        
        rank_list <- rank_list[as.numeric(rank_list) > 10]
        perc_list <- as.character(sapply(which(ranks != ""),
                                               function ( rank ){ ceiling(rank / length(col_gos2) * 10) }))
        if (length(rank_list) != 0) {
            # Consolidate ranks with same percentile 
            consolidator <- data.frame(rank_list,
                                       perc_list) %>%
                group_by(perc_list) %>%
                summarise_all(function ( x ) { paste(x, collapse=" / ") })
            rank_list <- consolidator$rank_list
            perc_list <- consolidator$perc_list
            
            # Extract pathing information
            path <- consolidator %>% mutate(source = gos1,
                                            group = name,
                                            value = (str_count(rank_list, "/") + 1) * 0.01) %>%
                select(source, target = perc_list, value, group)
            paths <<- rbind(paths, path)
            
            # Set up node information
            nodes[as.numeric(levels(perc_list))[perc_list] + 10] <<- as.character(perc_list)
            
            paste(paste(rank_list, collapse=", "), 
                  " (",
                  paste(perc_list, collapse=", "),
                  ")", sep="")
        } else {
            ""
        }
    })))
    colnames(matches) <- name
    matches$name <- rownames(matches)
    out <- list()
    out$matches <- matches[,c(2,1)]
    out$paths <- paths
    out$nodes <- nodes
    return(out)
}

unipept_topn <- unipept_all$Name[1:10]

tool1_label <- "EggNOG"
tool2_label <- "MEGAN"
tool3_label <- "MetaGOmics"
tool4_label <- "MPA"
tool5_label <- "Prophane"

tool1 <- getMatches(unipept_topn, eggnog_w_counts$name[1:200], tool1_label)
tool2 <- getMatches(unipept_topn, megan$name[1:200], tool2_label)
tool3 <- getMatches(unipept_topn, metagomics_filt$name[1:200], tool3_label)
tool4 <- getMatches(unipept_topn, pAll$name[1:200], tool4_label)
tool5 <- getMatches(unipept_topn, prophane$names[1:200], tool5_label)
# tool1 <- getMatches(unipept_topn, eggnog_w_counts$name, tool1_label)
# tool2 <- getMatches(unipept_topn, megan$name, tool2_label)
# tool3 <- getMatches(unipept_topn, metagomics_filt$name, tool3_label)
# tool4 <- getMatches(unipept_topn, pAll$name, tool4_label)
# tool5 <- getMatches(unipept_topn, prophane$names, tool5_label)
unipept_top_matches <- plyr::join_all(
        list(tool1$matches,
             tool2$matches,
            tool3$matches,
            tool4$matches,
            tool5$matches),
    by="name")
unipept_paths <- rbind(tool1$paths,
                       tool2$paths,
                       tool3$paths,
                       tool4$paths,
                       tool5$paths)
unipept_nodes <- data.frame(tool1$nodes,
                            tool2$nodes,
                            tool3$nodes,
                            tool4$nodes,
                            tool5$nodes)
colnames(unipept_nodes) <- c(tool1_label,
                             tool2_label,
                             tool3_label,
                             tool4_label,
                             tool5_label)
unipept_nodes
unipept_top_matches
```


```{r}
# Make each node unique by adding spaces after each one
unipept_nodes_final <- as.data.frame(sapply(1:length(unipept_nodes), function( index ) { 
    sapply(unipept_nodes[,index], function ( row ) { paste(row, paste(rep(" ",20 * index), collapse=""), sep="")})
}))
colnames(unipept_nodes_final) <- colnames(unipept_nodes)
unipept_nodes_final$header <- c(unipept_topn, 1:10)
unipept_nodes_final <- unipept_nodes_final[,c(6,1,2,3,4,5)]

# Make each path unique by adding spaces after each one 
unipept_paths_final <- data.frame(unipept_paths)
unipept_paths_final$target <- sapply(1:nrow(unipept_paths), function ( x ) { 
    index <- which(colnames(unipept_nodes) == unipept_paths[x,]$group)
    paste(unipept_paths[x,]$target, paste(rep(" ",20 * index), collapse=""), sep="") } )
unipept_nodes_final
unipept_paths_final
```

```{r}
# Set up node framework
framework <- data.frame()
sapply(1:(length(unipept_nodes_final) - 1), function ( i ) {
    framework <<- rbind(framework, 
                        data.frame(source = unipept_nodes_final[,i],
                                   target = unipept_nodes_final[,i + 1],
                                   group = "invisible",
                                   value = 1))
})
unipept_paths_final
```

```{r}
# Make a connection data frame
links <- rbind(framework, unipept_paths_final)
 
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes=data.frame(name=c(as.character(framework$source),
                        as.character(nodes$name[(nrow(framework) + 1):nrow(nodes)])) %>% unique())
links$IDsource=match(links$source, nodes$name)-1 
links$IDtarget=match(links$target, nodes$name)-1

nodes <- nodes %>% mutate(group = c(rep("block", 10),
                                    rep("invisible", 10),
                                    rep("top", 10),
                                    ifelse(gsub(" ", "", as.character(name[31:40])) == "", "invisible", tool1_label),
                                    rep("top", 10),
                                    ifelse(gsub(" ", "", as.character(name[51:60])) == "", "invisible", tool2_label),
                                    rep("top", 10),
                                    ifelse(gsub(" ", "", as.character(name[71:80])) == "", "invisible", tool3_label),
                                    rep("top", 10),
                                    ifelse(gsub(" ", "", as.character(name[91:100])) == "", "invisible", tool4_label),
                                    rep("top", 10),
                                    ifelse(gsub(" ", "", as.character(name[111:120])) == "", "invisible", tool5_label)))

# Normalize values
for (source in unique(unipept_paths_final$source)){
    paths <- links[links$source == source,] %>% filter (group != "invisible")
    print(source)
    #print(links[links$source == source & links$group == "invisible",])
    #print(links[links$source == source & links$group == "invisible",]$value)
    links[links$source == source & links$group == "invisible",]$value <- links[links$source == source & links$group == "invisible",]$value - sum(paths$value)
    print(links[links$source == source & links$group == "invisible",]$value)
}
for (target in unique(unipept_paths_final$target)){
    paths <- links[links$target == target,] %>% filter (group != "invisible")
    links[links$target == target & links$group == "invisible",]$value <- links[links$target == target & links$group == "invisible",]$value - sum(paths$value)
}

my_color <- paste('d3.scaleOrdinal() .domain(["invisible", "block", "top", "',
                  tool1_label, '", "',
                  tool2_label, '", "',
                  tool3_label, '", "',
                  tool4_label, '", "',
                  tool5_label, '"]) .range(["white", "black", "yellow", "red", "blue", "green", "orange", "purple"])', sep="")

# Make the Network. I call my colour scale with the colourScale argument
n <- sankeyNetwork(Links = links, Nodes = nodes, Source = "IDsource", Target = "IDtarget",
                   Value = "value", NodeID = "name", colourScale=my_color, LinkGroup="group", NodeGroup="group",
                   iterations = 0)
n
saveNetwork(n, "top100sankeyR.html", selfcontained = TRUE)
```
