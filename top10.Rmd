---
title: "Top N"
author: "Caleb Easterly"
date: "April 26, 2018"
output:
  html_document: default
  word_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The goal here is to estimate the top *n* 'things' that are changing across WS and NS, by fold change. The fold change is calculated by the sum of the spectral counts attributed to each 'thing' - in eggNOG mapper and BLAST, the counts are aggregated by protein; in MEGAN, they are aggregated by eggNOG orthologous group; and in metaGOmics and Unipept, they are assigned to GO terms. In all cases, the Laplace correction is made, which is just adding 1 to all observed counts. This prevents division by zero, and allows for fold change estimation when one 'thing' was seen in one sample but not in another. 

# Reading in data
Necessary packages:
```{r message=FALSE}
library(GO.db)
library(data.table)
library(dplyr)
library(kableExtra)
library(stringr)
library(networkD3)
library(tidyverse)
```

## Peptides

These are the counts used in eggNOG-mapper and BLAST results interpretation. 

```{r}
peptidesNS <- read.delim("peptide_shaker_outputs/737NS_Peptide_Shaker_Peptide_Report.tabular",
                         stringsAsFactors = FALSE) %>%
    select(peptide = Sequence, countNS = "X.Validated.PSMs")

peptidesWS <- read.delim("peptide_shaker_outputs/737WS_Peptide_Shaker_Peptide_Report.tabular",
                         stringsAsFactors = FALSE) %>%
    select(peptide = Sequence, countWS = "X.Validated.PSMs") 

norm_ratio <- sum(peptidesWS$countWS) / sum(peptidesNS$countNS)
peptidesNS$countNS <- peptidesNS$countNS * sum(peptidesWS$countWS) / sum(peptidesNS$countNS)
peptides_all <- full_join(peptidesNS, peptidesWS, by = "peptide")
peptides_all[is.na(peptides_all)] <- 0
peptides_all
write.table(peptides_all$peptide, file="peptide_shaker_outputs/peptides_all.txt",
            quote = FALSE, row.names = FALSE, col.names = FALSE)
```

## Filter ontologies based on molecular function, biological process, or cellular component
```{r}
ontology <- "MF"
filterOntology <- function(go_list, ontology){
    if (ontology == "all") { return(go_list) }
    sapply(go_list, function (go_cell) {
        go_list <- strsplit(go_cell, ",")[[1]]
        onts <- Ontology(go_list)
        filtered_gos <- go_list[onts == ontology & !is.na(onts) & onts != ""]
        return(paste(filtered_gos, collapse = ","))
    })
}
```

## eggNOG mapper results

Join peptides to counts, and calculate ratios.

```{r}
eggnog <- read.delim("eggnogmap_results/diamond_annotations.tabular",
                     stringsAsFactors = FALSE,
                     header = FALSE) %>% 
    select(peptide = V1, protein = V2, gene = V5, go = V6, ko = V7, desc = V13)
eggnog_w_counts <- left_join(eggnog,
                             peptides_all,
                             by = "peptide") %>%
    group_by(protein, desc, gene, go) %>%
    summarize(countWS = sum(countWS), countNS = sum(countNS)) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio) %>%
    select(protein, go, gene, countWS, countNS, log2ratio, desc)
eggnog_w_counts$go <- filterOntology(eggnog_w_counts$go, ontology)
eggnog_w_counts$name <- sapply(strsplit(eggnog_w_counts$go, ","), function ( x ) { paste(Term(x), collapse="; ")})
eggnog_w_counts
```


Top *N*:
```{r echo=FALSE, results='asis'}
library(knitr)
n <- 10
kable(head(eggnog_w_counts, n), caption = paste("eggNOG-mapper: top", n, "fold changes"))
```

The <a href="http://pfam.xfam.org/family/PF05658">Pfam:YadA</a> refers to the YadA head domain in the trimeric autotransporter adhesin protein family. 

## Blast
# ```{r}
# blast <- read.delim('blast_results/blastp_vs_nr_current.tabular',
#                     stringsAsFactors = FALSE,
#                     header = FALSE) %>%
#     select(peptide = V1, protein = V2, desc = V25)
# 
# blast_counts <- left_join(blast, peptides_all, by = "peptide") %>%
#     group_by(protein, desc) %>%
#     filter(!is.na(countWS) & !is.na(countNS)) %>%
#     summarize(sumCountWS = sum(countWS) + 1, sumCountNS = sum(countNS) + 1) %>%
#     mutate(log2ratio = log2(sumCountWS/sumCountNS)) %>%
#     arrange(-log2ratio)
# ```
# 
# Print results:
# ```{r echo=FALSE, results='asis'}
# kable(head(blast_counts, n), caption = paste("BLAST: Top ", n, " fold changes"))
# ```

## metaGOmics

We take the top *n* results that have a FDR-corrected $q$ value less than 0.05. 

```{r}
metagomics <- read.delim("metaGOmics_results/go_compare_149_150.txt",
                         comment.char = "#") %>%
    select(go = GO.acc,
           name = GO.name,
           log2ratio =  Laplace.corr..Log.2..fold.change,
           p = Laplace.corr..q.value) %>%
    filter(Ontology(as.character(go)) == ontology)

metagomics_filt <- metagomics %>% filter(p < 0.05) %>%
    arrange(-log2ratio)
metagomics_filt
```

Top *n* results:
```{r echo=FALSE, results='asis'}
kable(head(metagomics_filt, n), caption = paste("MetaGOmics: Top", n, "fold changes"))
```

## MEGAN

```{r}
megan <- read.delim("MEGAN_outputs/737NSvsWS_EGGNOGcount.csv") %>%
    select(og = X.Datasets, countNS = X737_NS_BLASTOutput_2StepCombined,
           countWS = X737_WS_BLASTOutput_2StepCombined) %>%
    mutate(corrWS = countWS + 1,
           corrNS = countNS + 1,
           log2ratio = log2(corrWS/corrNS)) %>%
    arrange(-log2ratio)
megan_go <- read.delim("MEGAN_outputs/go_terms.txt",
                        header = TRUE,
                        stringsAsFactors = FALSE)
# Double check that GO terms are in order (randomly check ten times for parity)
sapply(sample(1:nrow(megan), 10, replace=T), function ( n ) {
    grepl(megan_go[n, "og"], megan[n, "og"])
})
megan$countNS <- megan$countNS * norm_ratio
megan$go <- filterOntology(megan_go$go, ontology)
megan$name <- sapply(strsplit(megan$go, ","), function ( x ) { paste(Term(x), collapse="; ")})
```
```{r}
sum(megan$countWS)
sum(megan$countNS)
sum(megan$countWS) / sum(megan$countNS)
norm_ratio
```

Top *n* results:
```{r echo=FALSE, results='asis'}
kable(head(megan, n), caption = paste("MEGAN: Top", n, "fold changes"))
```

Note that <a href="https://enzyme.expasy.org/EC/3.2.1.52">EC 3.2.1.52</a> is a beta-hexosaminidase and <a href="http://eggnogdb.embl.de/#/app/results?target_nogs=ENOG410YESU">ENOG410YESU</a> is involved in cell wall/membrane/envelope biogenesis.

## Unipept

```{r}
unipept_results_NS <- paste('unipept_results/',
                               list.files("unipept_results/", pattern = "^737NS.*\\.csv"),
                               sep = "")
unipept_results_WS <- paste('unipept_results/',
                               list.files("unipept_results/", pattern = "^737WS.*\\.csv"),
                               sep = "")
unipeptNS <- lapply(unipept_results_NS, function(i) {
        read.delim(i, sep = ',', as.is = TRUE)}) %>%
    bind_rows() %>%
    select(-X) %>%
    rename(peptides = X.peptides)
unipeptNS$peptides = unipeptNS$peptides * norm_ratio
unipeptWS <- lapply(unipept_results_WS, function(i) {
    read.delim(i, sep = ',', as.is = TRUE)}) %>%
    bind_rows() %>%
    select(-X) %>%
    rename(peptides = X.peptides)

unipept_all <- inner_join(unipeptNS, unipeptWS, by = c("GO.term", "Name")) %>%
    mutate(countNS = peptides.x, countWS = peptides.y,
           log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    select(GO.term, name = Name, countWS, countNS, log2ratio) %>%
    filter(Ontology(GO.term) == ontology) %>%
    arrange(-log2ratio)
unipept_all
```
```{r}
sum(unipeptWS$peptides)
sum(unipeptNS$peptides) 
sum(unipeptWS$peptides) / sum(unipeptNS$peptides)
```


Top *n*:
```{r echo=FALSE, results='asis'}
kable(head(unipept_all, n), caption = paste("Unipept: top", n, "Fold Changes"))
```


## MetaProteomeAnalyzer

```{r}
ns_files <- list.files('mpa_results/NS', pattern = "_proteins.csv", full.names = TRUE)
pNS <- bind_rows(lapply(ns_files, function(i) read.delim(i, stringsAsFactors = FALSE))) %>%
    group_by(Protein.Accession, Protein.Description) %>%
    summarize("SpecCount" = sum(Spectral.Count))
ws_files <- list.files('mpa_results/WS', pattern = "_proteins.csv", full.names = TRUE)
pWS <- bind_rows(lapply(ws_files, function(i) read.delim(i, stringsAsFactors = FALSE))) %>%
    group_by(Protein.Accession, Protein.Description) %>%
    summarize("SpecCount" = sum(Spectral.Count))
pAll <- data.table(full_join(pNS, pWS, by=c("Protein.Accession", "Protein.Description")))
mpa_uniprot <- read.delim('mpa_results/uniprot_protein_results.tab', stringsAsFactors = FALSE)
pAll$gos <- as.character(sapply(pAll$Protein.Accession, function ( protid ) {
    goids <- mpa_uniprot[mpa_uniprot$Entry == protid,]$Gene.ontology.IDs
}))

# Normalization ratio
ns <- pAll$SpecCount.x
ws <- pAll$SpecCount.y
mpa_norm <- sum(ns[!is.na(ns)]) / sum(ws[!is.na(ws)])

# Separate the comma-delimited list of GOs into individual rows (retains the fold change value from the original row)
pAll[is.na(pAll)] <- 0
pAll <- pAll[ , list( gos = unlist( strsplit( gos , ";" ) ) ) , by = list(SpecCount.x, SpecCount.y) ]

# Collapse GO terms based on fold change values.
pAll$SpecCount.y <- pAll$SpecCount.y * mpa_norm
pAll <- pAll %>% group_by(gos) %>%
    summarize_all(sum) %>%
    select(countNS = SpecCount.x, countWS = SpecCount.y, gos) %>%
    mutate(name = Term(gsub(" ", "", gos)),
           log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
```

```{r}
ns <- pAll$SpecCount.x
ws <- pAll$SpecCount.y
sum(ns[!is.na(ns)])
sum(ws[!is.na(ws)])
sum(ns[!is.na(ns)]) / sum(ws[!is.na(ws)])
```


Top *n*:
```{r echo=FALSE, results='asis'}
kable(head(pAll, n), caption = paste("MetaProteomeAnalyzer: top", n, "Fold Changes"))
```

## Prophane

```{r}
prophane_WS <- read.delim("prophane_results/summary_WS.txt", sep = "\t",
                          stringsAsFactors = FALSE) %>% select(members_identifier,
                                                               ws = quant..sample_737..mean.,
                                                               ws_go1 = task_6..fun_from_TIGRFAMs_15_cut_tc..tigrfam2GO,
                                                               ws_go2 = task_7..fun_from_PFAMs_32..pfam2GO,
                                                               ws_go3 = task_8..fun_from_eggNog_4.5.1..og2GO)
prophane_NS <- read.delim("prophane_results/summary_NS.txt", sep = "\t",
                          stringsAsFactors = FALSE) %>% select(members_identifier,
                                                               ns = quant..sample_737..mean.,
                                                               ns_go1 = task_6..fun_from_TIGRFAMs_15_cut_tc..tigrfam2GO,
                                                               ns_go2 = task_7..fun_from_PFAMs_32..pfam2GO,
                                                               ns_go3 = task_8..fun_from_eggNog_4.5.1..og2GO)
prophane <- data.table(inner_join(prophane_NS, prophane_WS, by = c("members_identifier")) %>%
    filter(ns != "-", ws != "-") %>%
    mutate(fc = log2(as.double(ws)/as.double(ns)),
           gos = gsub(" ","", paste(ns_go1, ws_go1, ns_go2, ws_go2, ns_go3, ws_go3, sep=","))) %>%
    filter(gos != "") %>%
    select(fc, ws, ns, gos, ns_go1, ws_go1, ns_go2, ws_go2, ns_go3, ws_go3))
prophane$gos <- sapply(strsplit(prophane$gos,","), function(x) {
    terms <- filterOntology(unique(x[x != "-"]), ontology)
    paste(terms[terms != ""], collapse = ",")
})

# Separate the comma-delimited list of GOs into individual rows (retains the fold change value from the original row)
prophane <- prophane[ , list( gos = unlist( strsplit( gos , "," ) ) ) , by = list(fc, ws, ns) ]
prophane$name <- Term(prophane$gos)

# Collapse GO terms based on fold change values.
prophane <- prophane %>% group_by_at(vars(fc, ws, ns)) %>%
    summarize_all(paste, collapse="; ") %>%
    arrange(-fc)

prophane
```

## Unipept and MetaGOmics

This is comparing the estimated fold changes for GO terms for the two tools that natively use GO terms, Unipept and MetaGOmics. 

```{r}
um <- inner_join(unipept_all, metagomics, by = c("GO.term" = "go"))
png("um_cor.png", res = 700, width = 3.5, height = 4, units = "in")
plot(log2ratio.x ~ log2ratio.y, data = um, pch = 20, cex = 0.3, xlim=c(-8,8), ylim=c(-8,8),
     xlab = "Unipept: Log2 Ratio",
     ylab = "MetaGOmics: Log2 Ratio")
mod <- lm(log2ratio.x ~ log2ratio.y, data = um)
abline(0, 1, col = "red", lty = 2)
abline(coef(mod))
grid()
dev.off()
cor.test(um$log2ratio.x, um$log2ratio.y,
         method = "pearson", alternative = "two.sided")
nrow(um)
nrow(unipept_all)
nrow(metagomics)
```

### Rank comparison

How do metaGOmics and Unipept rankings compare? 

```{r}
top5_meta <- metagomics_filt$go[1:5]
m2u_ranks <- rep(0, 5)
u2m_ranks <- rep(0, 5)
top5_uni <- unipept_all$GO.term[1:5]
for (i in 1:5){
    m2u_rank <- which(unipept_all$GO.term == top5_meta[i])
    u2m_rank <- which(metagomics_filt$go == top5_uni[i])
    m2u_ranks[i] <- ifelse(length(m2u_rank) == 1, m2u_rank, NA)
    u2m_ranks[i] <- ifelse(length(u2m_rank) == 1, u2m_rank, NA)
}

m2u <- data.frame("go_term" = top5_meta,
                  "rank_in_metagomics" = 1:5,
                  "rank_in_unipept" = m2u_ranks)

u2m <- data.frame("go_term" = top5_uni,
                  "rank_in_unipept" = 1:5,
                  "rank_in_metagomics" = u2m_ranks)

```

### How Unipept Ranks MetaGOmics' top 5
```{r echo=FALSE, results='asis'}
kable(m2u)
```

### How MetaGOmics ranks Unipept's top 5
```{r echo=FALSE, results='asis'}
kable(u2m)
```

## Let's look at how the top terms are ranked in other tools

```{r}
getMatch <- function(gos1, gos2){
    delimiter <- "; "
    
    gos1 <- unique(unlist(strsplit(as.character(gos1), delimiter)))
    gos2 <- unique(unlist(strsplit(as.character(gos2), delimiter)))
    gos1 <- gos1[gos1 != "NA"]
    gos2 <- gos2[gos2 != "NA"]
    matched <- sapply(gos1, function ( go1 ) { 
        if(go1 %in% gos2){ go1 }
    })
    paste(unlist(matched), collapse="; ")
}

getMatches <- function(col_gos1, col_gos2, name){
    paths <- data.frame(source = character(),
                        target = character(),
                        group = character(),
                        value = numeric())
    nodes <- sapply(1:20, function ( x ) { paste(rep(" ", x), collapse="") })
    
    matches <- as.data.frame(unlist(sapply(col_gos1, function ( gos1 ){
        ranks <- lapply(col_gos2, function ( gos2){
            getMatch(gos1, gos2)
        })
        rank_list <- which(ranks != "")
        top_list <- rank_list[as.numeric(rank_list) <= 10]
        
        # Set up nodes and paths from top 10 matches
        if (length(top_list) != 0){
            topn <- paste("[", as.character(top_list), "]", sep="")
            nodes[top_list] <<- topn
            path <- data.frame(target = topn) %>%
                mutate(source = gos1,
                       value = 0.1,
                       percent = "NA",
                       group = name) %>%
                select(source, target, percent, value, group)
            paths <<- rbind(paths, path)
        }
        
        rank_list <- rank_list[as.numeric(rank_list) > 10]
        perc_list <- as.character(sapply(rank_list,
                                               function ( rank ){ ceiling(rank / length(col_gos2) * 10) }))
        if (length(rank_list) != 0) {
            # Consolidate ranks with same percentile 
            consolidator <- data.frame(rank_list,
                                       perc_list) %>%
                group_by(perc_list) %>%
                summarise_all(function ( x ) { paste(x, collapse=" / ") })
            rank_list <- consolidator$rank_list
            perc_list <- consolidator$perc_list
            
            # Extract pathing information
            path <- consolidator %>% mutate(source = gos1,
                                            group = name,
                                            value = (str_count(rank_list, "/") + 1) * 0.1) %>%
                                            #value = .01) %>%
                select(source, target = rank_list, percent = perc_list, value, group)
            paths <<- rbind(paths, path)
            
            # Set up node information
            nodes[as.numeric(levels(perc_list))[perc_list] + 10] <<- as.character(rank_list)
            
            paste(paste(rank_list, collapse=", "), 
                  " (",
                  paste(perc_list, collapse=", "),
                  ")", sep="")
        } else {
            ""
        }
    })))
    colnames(matches) <- name
    matches$name <- rownames(matches)
    out <- list()
    out$matches <- matches[,c(2,1)]
    out$paths <- paths
    out$nodes <- nodes
    return(out)
}

# Retains the first copy
removeDuplicates <- function(go_col){
    all_gos <- unique(unlist(str_split(go_col, "; ")))
    all_gos <- all_gos[all_gos != ""]
    filtered <- sapply(str_split(go_col, "; "), function ( go_list ) {
        output <- paste(go_list[go_list %in% all_gos], collapse="; ");
        all_gos <<- setdiff(all_gos, go_list)
        output
    })
    filtered <- filtered[filtered != ""]
    filtered <- filtered[filtered != "NA"]
    filtered[!is.na(filtered)]
}

eggnog_gos <- removeDuplicates(eggnog_w_counts$name)
# eggnog_gos <- eggnog_gos[!is.na(eggnog_gos)]
megan_gos <- removeDuplicates(megan$name)
metagomics_gos <- removeDuplicates(metagomics_filt$name)
mpa_gos <- removeDuplicates(pAll$name)
prophane_gos <- removeDuplicates(prophane$names)
unipept_gos <- removeDuplicates(unipept_all$name)

tools <- list()
tools$label <- c("EggNOG",
                 "MEGAN",
                 "MetaGOmics",
                 "MPA",
                 "Prophane",
                 "Unipept")
                    
tools$go_list <- c(list(eggnog_gos),
                   list(megan_gos),
                   list(metagomics_gos),
                   list(mpa_gos),
                   list(prophane_gos),
                   list(unipept_gos))
```

```{r}

get_rank_table <- function(tool_topn, tools, labels){
    rank_table <- data.frame(names = unlist(lapply(tool_topn, function(a) { rep(a, 2)})))
    for (i in 1:length(tools)){
        #print(labels[i])
        output <- sapply(tool_topn, function(topn){
            tool <- tools[i][[1]]
            rank <- which(grepl(topn, tool$name, fixed=TRUE))
            match <- tool[grepl(topn, tool$name, fixed=TRUE),]
            output1 <- output2 <- output3 <- ""
            sapply(1:nrow(match), function(row){
                if (row){
                    if (!is.na(rank[row])){
                        term <- match[row,]
                        output1 <<- paste(output1, rank[row])
                        output2 <<- paste(output2,
                                         ifelse(is.null(term$countWS) && is.null(term$countNS),
                                                '',
                                                paste(round(as.numeric(term$countWS), digits=2), '/',
                                                      round(as.numeric(term$countNS), digits=2), ' (',
                                                      round(as.numeric(term$log2ratio), digits=2), ')',
                                                      sep='')))
                    }
                }
            })
            # matches <- paste(matches, collapse=", ")
            # matches[grepl('NULL', matches)] <- ''
            # matches
            list(output1, output2)
        })
        rank_table[,labels[i]] <- unlist(output)
    }
    rank_table
}

# tool_topn
rank_table <- get_rank_table(unipept_all$name[1:10],
               list(unipept_all, eggnog_w_counts, megan, metagomics_filt, pAll, prophane),
               c("Unipept", "EggNOG", "MEGAN", "MetaGOmics", "MPA", "Prophane"))
rank_table
write.table(rank_table, file="rank_table.tabular", sep='\t', quote=FALSE, row.names=FALSE)
```

<!-- ```{r} -->
<!-- labels <- tools$label -->
<!-- #labels <- tools$label[1] -->
<!-- for (label in labels){ -->
<!--     print(label) -->

<!--     index <- which(label == tools$label) -->
<!--     go_lists <- tools$go_list[1:6 != index] -->
<!--     tool_topn <- tools$go_list[index][[1]][1:10] -->


<!--     labels <- tools$label[1:6 != index] -->

<!--     tool1 <- getMatches(tool_topn, go_lists[1][[1]], labels[1]) -->
<!--     tool2 <- getMatches(tool_topn, go_lists[2][[1]], labels[2]) -->
<!--     tool3 <- getMatches(tool_topn, go_lists[3][[1]], labels[3]) -->
<!--     tool4 <- getMatches(tool_topn, go_lists[4][[1]], labels[4]) -->
<!--     tool5 <- getMatches(tool_topn, go_lists[5][[1]], labels[5]) -->

<!--     top_matches <- plyr::join_all( -->
<!--         list(tool1$matches, -->
<!--              tool2$matches, -->
<!--              tool3$matches, -->
<!--              tool4$matches, -->
<!--              tool5$matches), -->
<!--         by="name") -->

<!--     sankey_paths <- rbind(tool1$paths, -->
<!--                           tool2$paths, -->
<!--                           tool3$paths, -->
<!--                           tool4$paths, -->
<!--                           tool5$paths) -->
<!--     sankey_nodes <- data.frame(tool1$nodes, -->
<!--                                tool2$nodes, -->
<!--                                tool3$nodes, -->
<!--                                tool4$nodes, -->
<!--                                tool5$nodes, stringsAsFactors = FALSE) -->
<!--     colnames(sankey_nodes) <- c(labels[1], -->
<!--                                 labels[2], -->
<!--                                 labels[3], -->
<!--                                 labels[4], -->
<!--                                 labels[5]) -->

<!--     # Collapse intersecting paths on same decile to contain same node name (range label with min and max rank) -->
<!--     ambiguous_paths <- sankey_paths[duplicated(sankey_paths[,c(3,5)]),] -->
<!--     ambiguous_paths <- unique(ambiguous_paths[,c(3,5)]) %>% filter(percent != "NA") -->
<!--     if (nrow(ambiguous_paths) > 0){ -->
<!--         for (index in 1:nrow(ambiguous_paths)){ -->
<!--             ambiguous_path <- ambiguous_paths[index,] -->
<!--             paths <- sankey_paths[sankey_paths$percent == ambiguous_path$percent & -->
<!--                                       sankey_paths$group == ambiguous_path$group,] -->
<!--             range <- paste(sort(unlist(sapply(paths$target, function ( x ) { strsplit(as.character(x), " / ")[[1]] } ))), collapse=", ") -->

<!--             # Update path and node -->
<!--             sankey_paths[sankey_paths$percent == ambiguous_path$percent & -->
<!--                              sankey_paths$group == ambiguous_path$group,]$target <- range -->
<!--             decile <- as.numeric(ambiguous_path$percent) -->
<!--             sankey_nodes[decile + 10, ambiguous_path$group] <- range -->
<!--         } -->
<!--     } -->
<!--     # Remove percent column  -->
<!--     sankey_paths <- subset(sankey_paths, select = -percent) -->

<!--     # Make each node unique by adding spaces after each one -->
<!--     sankey_nodes_final <- as.data.frame(sapply(1:length(sankey_nodes), function( index ) {  -->
<!--         sapply(sankey_nodes[,index], function ( row ) { paste(row, paste(rep(" ",20 * (index + 1)), collapse=""), sep="")}) -->
<!--     }), stringsAsFactors = FALSE) -->
<!--     colnames(sankey_nodes_final) <- colnames(sankey_nodes) -->

<!--     # Add placeholders, top ten terms, and decile labels -->
<!--     sankey_nodes_final <- cbind( -->
<!--         data.frame(sapply(1:20, function ( x ) { paste(rep(" ", x + 1), collapse="") })), -->
<!--         data.frame(Term = c(tool_topn, paste(seq(0, 90, by=10), " - ", seq(10, 100, by=10), "%", sep=""))), -->
<!--                                 sankey_nodes_final) -->
<!--     label_df <- data.frame(t(c(" ", label, labels))) -->
<!--     sankey_nodes_final <- rbind(label_df, setNames(sankey_nodes_final, names(label_df))) -->

<!--     # Make each path unique by adding spaces after each one  -->
<!--     sankey_paths_final <- data.frame(sankey_paths) -->
<!--     sankey_paths_final$target <- sapply(1:nrow(sankey_paths), function ( x ) {  -->
<!--         index <- which(colnames(sankey_nodes) == sankey_paths[x,]$group) -->
<!--         paste(sankey_paths[x,]$target, paste(rep(" ",20 * (index + 1)), collapse=""), sep="") } ) -->

<!--     # Set up node framework -->
<!--     framework <- data.frame(stringsAsFactors = FALSE) -->
<!--     sapply(1:(length(sankey_nodes_final) - 1), function ( i ) { -->
<!--         framework <<- rbind(framework,  -->
<!--                             data.frame(source = sankey_nodes_final[,i], -->
<!--                                        target = sankey_nodes_final[,i + 1], -->
<!--                                        group = "invisible", -->
<!--                                        value = 1, stringsAsFactors = FALSE)) -->
<!--     }) -->

<!--     # Make a connection data frame -->
<!--     links <- rbind(framework, sankey_paths_final) -->

<!--     # From these flows we need to create a node data frame: it lists every entities involved in the flow -->
<!--     nodes=data.frame(name=c(as.character(framework$source), -->
<!--                             as.character(sankey_nodes_final[,length(sankey_nodes_final)]))) -->
<!--     links$IDsource=match(links$source, nodes$name)-1  -->
<!--     links$IDtarget=match(links$target, nodes$name)-1 -->

<!--     offset <- 21 -->
<!--     nodes <- nodes %>% mutate(group = c(rep("invisible", 21), -->
<!--                                         "header", rep(label, 10), -->
<!--                                         rep("invisible", 10), -->
<!--                                         labels[1],  -->
<!--                                         ifelse(gsub(" ", "", as.character(name[(offset + 21 + 2):(offset + 30 + 2)])) == "", "top", labels[1]), -->
<!--                                         ifelse(gsub(" ", "", as.character(name[(offset + 31 + 2):(offset + 40 + 2)])) == "", "invisible", labels[1]), -->
<!--                                         labels[2],  -->
<!--                                         ifelse(gsub(" ", "", as.character(name[(offset + 41 + 3):(offset + 50 + 3)])) == "", "top", labels[2]), -->
<!--                                         ifelse(gsub(" ", "", as.character(name[(offset + 51 + 3):(offset + 60 + 3)])) == "", "invisible", labels[2]), -->
<!--                                         labels[3], -->
<!--                                         ifelse(gsub(" ", "", as.character(name[(offset + 61 + 4):(offset + 70 + 4)])) == "", "top", labels[3]), -->
<!--                                         ifelse(gsub(" ", "", as.character(name[(offset + 71 + 4):(offset + 80 + 4)])) == "", "invisible", labels[3]), -->
<!--                                         labels[4], -->
<!--                                         ifelse(gsub(" ", "", as.character(name[(offset + 81 + 5):(offset + 90 + 5)])) == "", "top", labels[4]), -->
<!--                                         ifelse(gsub(" ", "", as.character(name[(offset + 91 + 5):(offset + 100 + 5)])) == "", "invisible", labels[4]), -->
<!--                                         labels[5], -->
<!--                                         ifelse(gsub(" ", "", as.character(name[(offset + 101 + 6):(offset + 110 + 6)])) == "", "top", labels[5]), -->
<!--                                         ifelse(gsub(" ", "", as.character(name[(offset + 111 + 6):(offset + 120 + 6)])) == "", "invisible", labels[5]))) -->

<!--     # Normalize values -->
<!--     for (source in unique(sankey_paths_final$source)){ -->
<!--         paths <- links[links$source == source,] %>% filter (group != "invisible") -->
<!--         links[links$source == source & links$group == "invisible",]$value <- links[links$source == source & links$group == "invisible",]$value - sum(paths$value) -->
<!--     } -->
<!--     for (target in unique(sankey_paths_final$target)){ -->
<!--         paths <- links[links$target == target,] %>% filter (group != "invisible") -->
<!--         links[links$target == target & links$group == "invisible",]$value <- links[links$target == target & links$group == "invisible",]$value - sum(paths$value) -->
<!--     } -->

<!--     my_color <- paste('d3.scaleOrdinal() .domain(["invisible", "block", "header", "top", "', -->
<!--                       tools$label[1], '", "', -->
<!--                       tools$label[2], '", "', -->
<!--                       tools$label[3], '", "', -->
<!--                       tools$label[4], '", "', -->
<!--                       tools$label[5], '", "', -->
<!--                       tools$label[6], '"]) .range(["white", "black", "black", "#ffe070", "red", "blue", "green", "orange", "purple", "pink"])', sep="") -->

<!--     # Make the Network. I call my colour scale with the colourScale argument -->
<!--     n <- sankeyNetwork(Links = links, Nodes = nodes, Source = "IDsource", Target = "IDtarget", -->
<!--                        Value = "value", NodeID = "name", colourScale=my_color, LinkGroup="group", NodeGroup="group", -->
<!--                        iterations = 0) -->
<!--     print(n) -->
<!--     saveNetwork(n, paste("top100sankeyR-", label, ".html", sep=""), selfcontained = TRUE) -->
<!-- } -->
<!-- ``` -->

<!-- ## Extract peptides related to peptide deformylase activity -->

<!-- ```{r} -->
<!-- cov_pat <- "\ \\(.{2,4}\\)" -->
<!-- uni <- read.csv('unipept_results/mpa_result-all-peptides.csv', -->
<!--                 stringsAsFactors = FALSE) %>% -->
<!--     select(peptide, -->
<!--            #uni_go_bp = GO..biological.process., -->
<!--            uni_go_mf = GO..molecular.function. -->
<!--            #uni_go_cc = GO..cellular.component. -->
<!--            ) %>% -->
<!--     #filter(peptide %in% fivepep) %>% -->
<!--     mutate(#uni_go_bp = str_replace_all(string = uni_go_bp, pattern = cov_pat, replacement = ""), -->
<!--            uni_go_mf = str_replace_all(string = uni_go_mf, pattern = cov_pat, replacement = "") -->
<!--            #uni_go_cc = str_replace_all(string = uni_go_cc, pattern = cov_pat, replacement = "") -->
<!--            ) -->
<!-- uni$uni_go_names <- sapply(strsplit(uni$uni_go_mf, ";"), function ( x ) { paste(Term(x), collapse="; ")}) -->
<!-- uni -->
<!-- unipeptides <- uni[grepl("peptide deformylase activity", uni$uni_go_names),]$peptide -->
<!-- write.table(sort(unique(unipeptides)), file="peptide_deformylase_peptides_unipept/peptides.tab", -->
<!--             quote = FALSE, row.names = FALSE, col.names = FALSE) -->
<!-- for (peptide in unipeptides) { -->
<!--     write.table(paste(peptide, "10", sep="\t"), -->
<!--                 file= paste("peptide_deformylase_peptides_unipept/peptides/",peptide, ".tab", sep=""),  -->
<!--                 quote = FALSE, row.names = FALSE, col.names = FALSE)  -->
<!-- } -->
<!-- ``` -->

<!-- ```{r} -->
<!-- eggnog -->
<!-- eggnog$names <- sapply(strsplit(eggnog$go, ","), function ( x ) { paste(Term(x), collapse="; ")}) -->
<!-- eggnog[grepl("peptide deformylase activity", eggnog$names),] -->
<!-- ``` -->