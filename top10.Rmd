---
title: "Functional Tool Analysis Comparison"
author: "Ray Sajulga & Caleb Easterly"
date: "April 26, 2018"
output:
  html_document: default
  word_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The goal here is to estimate the top *n* 'things' that are changing across WS and NS, by fold change. The fold change is calculated by the sum of the spectral counts attributed to each 'thing' - in eggNOG mapper and BLAST, the counts are aggregated by protein; in MEGAN, they are aggregated by eggNOG orthologous group; and in metaGOmics and Unipept, they are assigned to GO terms. In all cases, the Laplace correction is made, which is just adding 1 to all observed counts. This prevents division by zero, and allows for fold change estimation when one 'thing' was seen in one sample but not in another. 

# Reading in data
Necessary packages:
```{r message=FALSE}
library(GO.db)
library(data.table)
library(dplyr)
library(kableExtra)
library(stringr)
library(networkD3)
library(tidyverse)
library(reticulate)
```

## Directories
```{r}
tools_dir <- "data/tool_outputs/func_tools/"
```


## Peptides

These are the counts used in eggNOG-mapper and BLAST results interpretation. 

```{r}
peptidesNS <- read.delim("data/tool_outputs/peptide_shaker_outputs/737NS_Peptide_Shaker_Peptide_Report.tabular",
                         stringsAsFactors = FALSE) %>%
    select(peptide = Sequence, countNS = "X.Validated.PSMs")

peptidesWS <- read.delim("data/tool_outputs/peptide_shaker_outputs/737WS_Peptide_Shaker_Peptide_Report.tabular",
                         stringsAsFactors = FALSE) %>%
    select(peptide = Sequence, countWS = "X.Validated.PSMs") 

norm_ratio <- sum(peptidesWS$countWS) / sum(peptidesNS$countNS)
peptidesNS$countNS <- peptidesNS$countNS * sum(peptidesWS$countWS) / sum(peptidesNS$countNS)
peptides_all <- full_join(peptidesNS, peptidesWS, by = "peptide")
peptides_all[is.na(peptides_all)] <- 0
peptides_all
write.table(peptides_all$peptide, file="data/tool_outputs/peptide_shaker_outputs/peptides_all.txt",
            quote = FALSE, row.names = FALSE, col.names = FALSE)
```

## We need to expand and collapse to the GO-term level
```{r}
expand_by_go <- function(go_df, delimiter){
    # Separate the comma-delimited list of GOs into individual rows
    # (retains the fold change value from the original row)
    # go_df <- go_df %>% select(countNS, countWS, gos)
    go_df <- go_df %>% mutate(countNS = as.numeric(countNS),
                              countWS = as.numeric(countWS))
    go_df <- data.table(go_df) 
    go_df <- go_df[ , list( gos = unlist( strsplit( gos , delimiter ) ) ) , by = list(countNS, countWS) ]

    # Collapse GO terms based on fold change values.
    go_df <- go_df %>% 
        group_by(gos) %>%
        select(countNS, countWS, gos) %>%
        summarize_all(sum) %>%
        mutate(name = Term(gsub(" ", "", gos)),
               log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
        arrange(-log2ratio)
    go_df
}
```

## eggNOG mapper results

Join peptides to counts, and calculate ratios.

```{r}
eggnog <- read.delim("data/tool_outputs/func_tools/eggnogmap_results/diamond_annotations.tabular",
                     stringsAsFactors = FALSE,
                     header = FALSE) %>% 
    select(peptide = V1, protein = V2, gene = V5, gos = V6, ko = V7, desc = V13)
eggnog_w_counts <- left_join(eggnog,
                             peptides_all,
                             by = "peptide") %>%
    group_by(protein, desc, gene, gos) %>%
    summarize(countWS = sum(countWS), countNS = sum(countNS)) %>%
    select(protein, gos, gene, countWS, countNS, desc)
#eggnog_w_counts$gos <- filterOntology(eggnog_w_counts$gos, ontology)
#eggnog_w_counts$name <- sapply(strsplit(eggnog_w_counts$gos, ","), function ( x ) { paste(Term(x), collapse="; ")})

eggnog_w_counts <- expand_by_go(eggnog_w_counts, ',')
eggnog_w_counts$name <- Term(eggnog_w_counts$gos)
eggnog_w_counts$namespace <- Ontology(eggnog_w_counts$gos)
eggnog_w_counts
```

Let's write a function to write out formatted input tabular files for metaquantome.
```{r}
write_mqome_inputs <- function(df, name, header, col_gos, col_samp1, col_samp2) {
    int_df <- df[c(header, col_samp1, col_samp2)]
    names(int_df)[1] <- 'peptide'
    write.table(int_df,
                file=paste0("results/mqome/input/", name, "/", name, "_int.tab"),
                quote=FALSE, row.names=FALSE, sep="\t")
    func_df <- df[c(header, col_gos)]
    names(func_df)[1] <- 'peptide'
    write.table(func_df,
                file=paste0("results/mqome/input/", name, "/", name, "_func.tab"),
                quote=FALSE, row.names=FALSE, sep="\t")
}
write_mqome_inputs(eggnog_w_counts, 'eggnog', 'gos', 'gos', 'countNS', 'countWS')
```


Top *N*:
```{r echo=FALSE, results='asis'}
library(knitr)
n <- 10
kable(head(eggnog_w_counts, n), caption = paste("eggNOG-mapper: top", n, "fold changes"))
```


The <a href="http://pfam.xfam.org/family/PF05658">Pfam:YadA</a> refers to the YadA head domain in the trimeric autotransporter adhesin protein family. 

## Blast
# ```{r}
# blast <- read.delim('blast_results/blastp_vs_nr_current.tabular',
#                     stringsAsFactors = FALSE,
#                     header = FALSE) %>%
#     select(peptide = V1, protein = V2, desc = V25)
# 
# blast_counts <- left_join(blast, peptides_all, by = "peptide") %>%
#     group_by(protein, desc) %>%
#     filter(!is.na(countWS) & !is.na(countNS)) %>%
#     summarize(sumCountWS = sum(countWS) + 1, sumCountNS = sum(countNS) + 1) %>%
#     mutate(log2ratio = log2(sumCountWS/sumCountNS)) %>%
#     arrange(-log2ratio)
# ```
# 
# Print results:
# ```{r echo=FALSE, results='asis'}
# kable(head(blast_counts, n), caption = paste("BLAST: Top ", n, " fold changes"))
# ```

## metaGOmics

We take the top *n* results that have a FDR-corrected $q$ value less than 0.05. 

```{r}
metagomics <- read.delim("data/tool_outputs/func_tools/metaGOmics_results/go_compare_149_150.txt",
                         comment.char = "#") %>%
    select(gos = GO.acc,
           name = GO.name,
           countNS = Run.1.PSM.count,
           countWS = Run.2.PSM.count,
           log2ratio =  Laplace.corr..Log.2..fold.change,
           p = Laplace.corr..q.value) #%>%
    # filter(Ontology(as.character(go)) == ontology)

metagomics_filt <- metagomics %>% filter(p < 0.05) %>%
    arrange(-log2ratio)
metagomics_filt$namespace <- Ontology(as.character(metagomics_filt$go))
metagomics_filt
```

Top *n* results:
```{r echo=FALSE, results='asis'}
kable(head(metagomics_filt, n), caption = paste("MetaGOmics: Top", n, "fold changes"))
```

Metaquantome-normalized dataset:
```{r}
write_mqome_inputs(metagomics_filt, 'metagomics', 'gos', 'gos', 'countNS', 'countWS')
```

## MEGAN

```{r}
megan <- read.delim("data/tool_outputs/func_tools/MEGAN_outputs/737NSvsWS_EGGNOGcount.csv") %>%
    select(og = X.Datasets, countNS = X737_NS_BLASTOutput_2StepCombined,
           countWS = X737_WS_BLASTOutput_2StepCombined)
megan_go <- read.delim("data/tool_outputs/func_tools/MEGAN_outputs/go_terms.txt",
                        header = TRUE,
                        stringsAsFactors = FALSE)
megan$gos <- megan_go$gos
megan$countNS <- megan$countNS * norm_ratio
# megan$gos <- filterOntology(megan_go$gos, ontology)

megan <- expand_by_go(megan, ',')
megan$name <- Term(megan$gos)
megan$namespace <- Ontology(megan$gos)
megan
```

```{r}
sum(megan$countWS)
sum(megan$countNS)
sum(megan$countWS) / sum(megan$countNS)
norm_ratio
```

Top *n* results:
```{r echo=FALSE, results='asis'}
kable(head(megan, n), caption = paste("MEGAN: Top", n, "fold changes"))
```

Note that <a href="https://enzyme.expasy.org/EC/3.2.1.52">EC 3.2.1.52</a> is a beta-hexosaminidase and <a href="http://eggnogdb.embl.de/#/app/results?target_nogs=ENOG410YESU">ENOG410YESU</a> is involved in cell wall/membrane/envelope biogenesis.

Metaquantome-normalized dataset:
```{r}
write_mqome_inputs(megan, 'megan', 'gos', 'gos', 'countNS', 'countWS')
```

## Unipept

```{r}
unipept_results_NS <- paste0(tools_dir, 'unipept_results/',
                               list.files(paste0(tools_dir, 'unipept_results/'), pattern = "^737NS.*\\.csv"))
unipept_results_WS <- paste0(tools_dir, 'unipept_results/',
                               list.files(paste0(tools_dir, 'unipept_results/'), pattern = "^737WS.*\\.csv"))
unipeptNS <- lapply(unipept_results_NS, function(i) {
        read.delim(i, sep = ',', as.is = TRUE)}) %>%
    bind_rows() %>%
    select(-X) %>%
    rename(peptides = X.peptides)
unipeptNS$peptides = unipeptNS$peptides * norm_ratio
unipeptWS <- lapply(unipept_results_WS, function(i) {
    read.delim(i, sep = ',', as.is = TRUE)}) %>%
    bind_rows() %>%
    select(-X) %>%
    rename(peptides = X.peptides)

unipept_all <- inner_join(unipeptNS, unipeptWS, by = c("GO.term", "Name")) %>%
    mutate(countNS = peptides.x, countWS = peptides.y,
           log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    select(gos = GO.term, name = Name, countWS, countNS, log2ratio) %>%
    # filter(Ontology(GO.term) == ontology) %>%
    arrange(-log2ratio)
unipept_all$namespace <- Ontology(unipept_all$gos)
unipept_all
```

```{r}
sum(unipeptWS$peptides)
sum(unipeptNS$peptides) 
sum(unipeptWS$peptides) / sum(unipeptNS$peptides)
```


Top *n*:
```{r echo=FALSE, results='asis'}
kable(head(unipept_all, n), caption = paste("Unipept: top", n, "Fold Changes"))
```

Metaquantome-normalized dataset:
```{r}
write_mqome_inputs(unipept_all, 'unipept', 'gos', 'gos', 'countNS', 'countWS')
```

## MetaProteomeAnalyzer

```{r}
ns_files <- list.files('data/tool_outputs/func_tools/mpa_results/NS', pattern = "_proteins.csv", full.names = TRUE)
pNS <- bind_rows(lapply(ns_files, function(i) read.delim(i, stringsAsFactors = FALSE))) %>%
    group_by(Protein.Accession, Protein.Description) %>%
    summarize("SpecCount" = sum(Spectral.Count))
ws_files <- list.files('data/tool_outputs/func_tools/mpa_results/WS', pattern = "_proteins.csv", full.names = TRUE)
pWS <- bind_rows(lapply(ws_files, function(i) read.delim(i, stringsAsFactors = FALSE))) %>%
    group_by(Protein.Accession, Protein.Description) %>%
    summarize("SpecCount" = sum(Spectral.Count))
pAll <- data.table(full_join(pNS, pWS, by=c("Protein.Accession", "Protein.Description"))) %>%
    rename(countNS = SpecCount.x, countWS = SpecCount.y, )

mpa_uniprot <- read.delim('data/tool_outputs/func_tools/mpa_results/uniprot_protein_results.tab', stringsAsFactors = FALSE)
pAll$gos <- as.character(sapply(pAll$Protein.Accession, function ( protid ) {
    goids <- mpa_uniprot[mpa_uniprot$Entry == protid,]$Gene.ontology.IDs
}))

# Normalization ratio
mpa_norm <- sum(pAll$countNS[!is.na(pAll$countNS)]) / sum(pAll$countWS[!is.na(pAll$countWS)])
pAll$countWS <- pAll$countWS * mpa_norm

pAll[is.na(pAll)] <- 0

pAll <- collapse_by_go(pAll, "; ")
pAll$namespace <- Ontology(pAll$gos)
pAll
```

```{r}
ns <- pAll$SpecCount.x
ws <- pAll$SpecCount.y
sum(ns[!is.na(ns)])
sum(ws[!is.na(ws)])
sum(ns[!is.na(ns)]) / sum(ws[!is.na(ws)])
```


Top *n*:
```{r echo=FALSE, results='asis'}
kable(head(pAll, n), caption = paste("MetaProteomeAnalyzer: top", n, "Fold Changes"))
```

Metaquantome-normalized dataset:
```{r}
write_mqome_inputs(pAll, 'mpa', 'gos', 'gos', 'countNS', 'countWS')
```


## Prophane

```{r}
prophane_WS <- read.delim(paste0(tools_dir, "prophane_results/summary_WS.txt"), sep = "\t",
                          stringsAsFactors = FALSE) %>% select(members_identifier,
                                                               ws = quant..sample_737..mean.,
                                                               ws_go1 = task_6..fun_from_TIGRFAMs_15_cut_tc..tigrfam2GO,
                                                               ws_go2 = task_7..fun_from_PFAMs_32..pfam2GO,
                                                               ws_go3 = task_8..fun_from_eggNog_4.5.1..og2GO)
prophane_NS <- read.delim(paste0(tools_dir, "prophane_results/summary_NS.txt"), sep = "\t",
                          stringsAsFactors = FALSE) %>% select(members_identifier,
                                                               ns = quant..sample_737..mean.,
                                                               ns_go1 = task_6..fun_from_TIGRFAMs_15_cut_tc..tigrfam2GO,
                                                               ns_go2 = task_7..fun_from_PFAMs_32..pfam2GO,
                                                               ns_go3 = task_8..fun_from_eggNog_4.5.1..og2GO)
prophane <- data.table(inner_join(prophane_NS, prophane_WS, by = c("members_identifier")) %>%
    filter(ns != "-", ws != "-") %>%
    mutate(gos = gsub(" ","", paste(ns_go1, ws_go1, ns_go2, ws_go2, ns_go3, ws_go3, sep=","))) %>%
    filter(gos != "") %>%
    select(countWS = ws, countNS = ns, gos, ns_go1, ws_go1, ns_go2, ws_go2, ns_go3, ws_go3))
# prophane$gos <- sapply(strsplit(prophane$gos,","), function(x) {
#     terms <- filterOntology(unique(x[x != "-"]), ontology)
#     paste(terms[terms != ""], collapse = ",")
# })
prophane <- collapse_by_go(prophane, ',') %>%
    mutate(log2ratio = log2(as.double(countWS)/as.double(countNS))) %>%
    arrange(-log2ratio)
prophane$namespace <- Ontology(prophane$gos)
prophane
```

Metaquantome-normalized dataset:
```{r}
write_mqome_inputs(prophane, 'prophane', 'gos', 'gos', 'countNS', 'countWS')
```

Let's expand and filter using metaquantome
```{r}
print_mqome_cmds <- function(name, func_colname){
  cmd_expand <- paste0("metaquantome expand --mode f --data_dir data/databases/gene_ontology/mqome",
                        " --int_file results/mqome/input/", name, "/", name, "_int.tab",
                       " --pep_colname_int peptide",
                       " --func_file results/mqome/input/", name, "/", name, "_func.tab",
                       " --pep_colname_func peptide",
                       " --func_colname ", func_colname," --ontology go",
                       " --samps results/mqome/input/samples.tab",
                       " --outfile results/mqome/output/", name, "/", name, "_func_expanded.tab")
  cmd_filt <- paste0("metaquantome filter",
                     " --expand_file results/mqome/output/", name, "/", name, "_func_expanded.tab",
                     " --mode f --ontology go",
                     " --samps results/mqome/input/samples.tab",
                     " --min_peptides 2 --min_pep_nsamp 1 --min_children_non_leaf 2 --min_child_nsamp 0",
                     " --qthreshold 0 --outfile results/mqome/output/", name, "/", name, "_func_filtered.tab")
  return(paste(cmd_expand, cmd_filt, sep='; '))
}
paste(print_mqome_cmds("eggnog", 'gos'),
      print_mqome_cmds("metagomics", "gos.1"),
      print_mqome_cmds("megan", "gos"),
      print_mqome_cmds("mpa", "gos"),
      print_mqome_cmds("prophane", "gos"),
      print_mqome_cmds("unipept", "gos.1"), sep='; ')
```


```{r}
eggnog_expanded <- read.delim("results/mqome/output/eggnog/eggnog_func_expanded.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
eggnog_filtered <- read.delim("results/mqome/output/eggnog/eggnog_func_filtered.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
unipept_expanded <- read.delim("results/mqome/output/unipept/unipept_func_expanded.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
unipept_filtered <- read.delim("results/mqome/output/unipept/unipept_func_filtered.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
metagomics_expanded <- read.delim("results/mqome/output/metagomics/metagomics_func_expanded.tab",
                             stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
metagomics_filtered <- read.delim("results/mqome/output/metagomics/metagomics_func_filtered.tab",
                             stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
mpa_expanded <- read.delim("results/mqome/output/mpa/mpa_func_expanded.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
mpa_filtered <- read.delim("results/mqome/output/mpa/mpa_func_filtered.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
prophane_expanded <- read.delim("results/mqome/output/prophane/prophane_func_expanded.tab",
                                stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
prophane_filtered <- read.delim("results/mqome/output/prophane/prophane_func_filtered.tab",
                                stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
megan_expanded <- read.delim("results/mqome/output/megan/megan_func_expanded.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
megan_filtered <- read.delim("results/mqome/output/megan/megan_func_filtered.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
```

## Unipept and MetaGOmics

This is comparing the estimated fold changes for GO terms for the two tools that natively use GO terms, Unipept and MetaGOmics. 

## Function for filtering ontologies
```{r}
filterOntology <- function(tool, ontology){
  translations <- list("MF" = "molecular_function", "BP" = "biological_process", "CC" = "cellular_component")
  tool %>% filter(namespace %in% c(ontology, translations[ontology][[1]]))
}
```
```{r}
filterOntology(unipept_all, "MF")
```

```{r}
plot_correlation <- function(unipept, metagomics, header, dims, ontology, suffix=''){
  if (ontology != 'all'){
    unipept <- filterOntology(unipept, ontology)
    metagomics <- filterOntology(metagomics, ontology)
  }
  if (nrow(unipept)){
    um <- inner_join(unipept, metagomics, by = header)
    png(paste0("results/correlation/um_cor", paste(suffix, ontology, sep='-'), ".png"),
        res = 700, width = 3.5, height = 4, units = "in")
    plot(log2ratio.x ~ log2ratio.y, data = um, pch = 20, cex = 0.3, xlim=dims, ylim=dims,
         xlab = "Unipept: Log2 Ratio",
         ylab = "MetaGOmics: Log2 Ratio")
    mod <- lm(log2ratio.x ~ log2ratio.y, data = um)
    abline(0, 1, col = "red", lty = 2)
    abline(coef(mod))
    grid()
    dev.off()
    results <- cor.test(um$log2ratio.x, um$log2ratio.y,
             method = "pearson", alternative = "two.sided")
    print(paste0(ontology, suffix))
    print(nrow(um))
    print(nrow(unipept))
    print(nrow(metagomics))
    print(results)
    results
  }
}

results <- sapply(c("MF", "CC", "BP", "all"),
                  function(ontology){
                    list(plot_correlation(unipept_all, metagomics_filt,
                                          'gos', c(-8, 8), ontology),
                         plot_correlation(unipept_filtered, metagomics_filtered, 
                                          'id', c(-1.5, 1.5), ontology, suffix='-filtered'))
                  })

```

### Rank comparison

How do metaGOmics and Unipept rankings compare? 

```{r}
top5_meta <- metagomics_filt$go[1:5]
m2u_ranks <- rep(0, 5)
u2m_ranks <- rep(0, 5)
top5_uni <- unipept_all$GO.term[1:5]
for (i in 1:5){
    m2u_rank <- which(unipept_all$GO.term == top5_meta[i])
    u2m_rank <- which(metagomics_filt$go == top5_uni[i])
    m2u_ranks[i] <- ifelse(length(m2u_rank) == 1, m2u_rank, NA)
    u2m_ranks[i] <- ifelse(length(u2m_rank) == 1, u2m_rank, NA)
}
# 
# m2u <- data.frame("go_term" = top5_meta,
#                   "rank_in_metagomics" = 1:5,
#                   "rank_in_unipept" = m2u_ranks)
# 
# u2m <- data.frame("go_term" = top5_uni,
#                   "rank_in_unipept" = 1:5,
#                   "rank_in_metagomics" = u2m_ranks)

```

### How Unipept Ranks MetaGOmics' top 5
```{r echo=FALSE, results='asis'}
kable(m2u)
```

### How MetaGOmics ranks Unipept's top 5
```{r echo=FALSE, results='asis'}
kable(u2m)
```

### Top Ten Tables
```{r}
get_rank_table <- function(name, tools, folder){
    n <- 10
    if (name == "Unipept"){
        n <- 15
    }
    labels <- c("EggNOG", "MEGAN", "MetaGOmics", "MPA", "Prophane", "Unipept")
    tool_topn <- tools[which(labels == name)][[1]]$name[1:n]
    rank_table <- data.frame(names = unlist(lapply(tool_topn, function(a) { c(as.character(a), '')})))
    rank_table[,"Ranking"] <- rep(c('FC (WS / NS)', 'Percentile (%)'), n)
    for (i in 1:length(tools)){
        output <- sapply(tool_topn, function(topn){
            tool <- tools[i][[1]]
            rank <- which(grepl(topn, tool$name, fixed=TRUE))
            if (length(rank) > 0){
                term <- tool[rank[[1]],]
                list(paste(ifelse(is.null(term$countWS) && is.null(term$countNS),
                                       paste0('(', round(as.numeric(term$log2ratio), digits=2), ')'),
                                       paste0(round(as.numeric(term$log2ratio), digits=2),
                                              ' (', round(as.numeric(term$countWS), digits=2), ' / ',
                                                    round(as.numeric(term$countNS), digits=2), ')'))),
                     round(as.numeric(rank[[1]] / nrow(tool) * 100), digits=3))
            } else {
                list('-','-')
            }
        })
        rank_table[,labels[i]] <- unlist(output)
    }
    rank_table <- rank_table %>% select('GO Term' = names, "Ranking", name, everything())
    write.table(rank_table,
                file=paste0("results/rank_tables/", folder, "/", name, "-rank_table.tabular"),
                sep='\t', quote=FALSE, row.names=FALSE)
}

# tool_topn
remove_blanks <- function(go_list){
    go_list[go_list$name != "",]
}

filterOntology <- function(go_list, ontology){
  if (ontology == "all") { return(go_df) }
  sapply(go_list, function (go_cell) {
    go_list <- strsplit(toString(go_cell), ",")[[1]]
    onts <- Ontology(go_list)
    filtered_gos <- go_list[onts == ontology & !is.na(onts) & onts != ""]
    return(paste(filtered_gos, collapse = ","))
    })
}

ontology <- 'MF'
tools <- list(remove_blanks(filterOntology(eggnog_w_counts, ontology)),
              remove_blanks(filterOntology(megan, ontology)),
              remove_blanks(filterOntology(metagomics_filt, ontology)),
              remove_blanks(filterOntology(pAll, ontology)),
              remove_blanks(filterOntology(prophane, ontology)),
              remove_blanks(filterOntology(unipept_all, ontology)))
get_rank_table("Unipept", tools, 'full')
get_rank_table("EggNOG", tools, 'full')
get_rank_table("MEGAN", tools, 'full')
get_rank_table("MetaGOmics", tools, 'full')
get_rank_table("MPA", tools, 'full')
get_rank_table("Prophane", tools, 'full')

tools <- list(remove_blanks(filterOntology(eggnog_filtered, ontology)),
              remove_blanks(filterOntology(megan_filtered, ontology)),
              remove_blanks(filterOntology(metagomics_filtered, ontology)),
              remove_blanks(filterOntology(mpa_filtered, ontology)),
              remove_blanks(filterOntology(prophane_filtered, ontology)),
              remove_blanks(filterOntology(unipept_filtered, ontology)))
get_rank_table("Unipept", tools, 'filtered')
get_rank_table("EggNOG", tools, 'filtered')
get_rank_table("MEGAN", tools, 'filtered')
get_rank_table("MetaGOmics", tools, 'filtered')
get_rank_table("MPA", tools, 'filtered')
#get_rank_table("Prophane", tools, 'filtered')
```

### GO list exporting
```{r}
labels <- c("EggNOG", "MEGAN", "MetaGOmics", "MPA", "Prophane", "Unipept")
tools <- list(eggnog_w_counts, megan, metagomics_filt, pAll, prophane, unipept_all)
for (i in 1:length(tools)){
  write.table(tools[i], file=paste0('results/go_output/', tolower(labels[i]), '.tabular'),
              row.names=FALSE, quote=FALSE)
}
```


### Overlap Plot Generation
```{r}
library(reshape2)
library(ggplot2)

generate_overlap_plot <- function(ontology){
  
  
  labels <- c("EggNOG", "MEGAN", "MetaGOmics", "MPA", "Prophane", "Unipept")
  tools_mqome <- list(eggnog_filtered, megan_filtered, metagomics_filtered,
                      mpa_filtered, prophane_filtered, unipept_filtered)
  filtered_tools <- function(tools, ontology){
    translations <- list("MF" = "molecular_function",
                         "BP" = "biological_process",
                         "CC" = "cellular_component")
    lapply(tools, function( tool ) { tool %>% filter(namespace %in% c(ontology, translations[ontology][[1]]))})
  }
  gos <- sapply(filtered_tools(tools, ontology), function(tool){ tool$gos})
  
  jaccard <- function(vec1, vec2){
    c1 <- length(vec1)
    c2 <- length(vec2)
    int <- length(intersect(vec1, vec2))
    int / c1
  }
  
  jacmat <- matrix(0, nrow = 6, ncol = 6)
  for (i in 1:6){
    for (j in 1:6){
      jacmat[i, j] <- jaccard(unique(gos[[i]]), unique(gos[[j]]))
    }
  }
  dimnames(jacmat) <- list(labels, labels)
  
  # gos_filt <- list('eggnog' = unique(filterOntology(eggnog_filtered$id, ontology)),
  #         'megan' = unique(filterOntology(megan_filtered$id, ontology)),
  #         'metagomics' = unique(filterOntology(metagomics_filtered$id, ontology)),
  #         'mpa' = unique(filterOntology(mpa_filtered$id, ontology)),
  #         'prophane' = unique(filterOntology(prophane_filtered$id, ontology)),
  #         'unipept' = unique(filterOntology(unipept_filtered$id, ontology)))
  
  gos_filt <- sapply(filtered_tools(tools_mqome, ontology), function(tool){ tool$id })
  
  
  jacslim <- matrix(0, nrow = 6, ncol = 6)
  for (i in 1:6){
    for (j in 1:6){
      jacslim[i, j] <- jaccard(unique(gos_filt[[i]]),
                               unique(gos_filt[[j]]))
    }
  }
  dimnames(jacslim) <- list(labels, labels)
  
  jac_melt <- melt(jacmat)
  jac_melt$method <- "Full GO"
  
  jac_melt_slim <- melt(jacslim)
  jac_melt_slim$method <- "Metaquantome-Filtered GO"
  
  jac_melt_all <- rbind(jac_melt, jac_melt_slim)
  
  ggplot(jac_melt_all)+
    geom_tile(aes(x = Var1, y = Var2, fill = value), color = "black") +
    geom_text(aes(x = Var1, y = Var2, label = format(value, digits = 2))) + 
    scale_fill_gradient(name="", low = "white", high = "dodgerblue", limits = c(0, 1),
                        guide = guide_colorbar(frame.colour = "black", ticks.colour = "black")) +
    facet_grid(.~method) +
    theme_minimal(base_size = 14) +
    theme(aspect.ratio = 1, axis.text.x = element_text(angle = 90)) +
    labs(x = NULL, y = NULL)
  ggsave(paste0("results/overlap_plots/overlap-", paste(ontology, collapse="-"), "-filtered.png"),
         height = 5, width = 12, units = "in", dpi = 700)
}

generate_overlap_plot(c("MF", "BP", "CC"))
generate_overlap_plot("MF")
generate_overlap_plot("BP")
generate_overlap_plot("CC")
```