---
title: "Functional Tool Analysis Comparison"
author: "Ray Sajulga & Caleb Easterly"
date: "April 26, 2018"
output:
  html_document: default
  word_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The goal here is to estimate the top *n* 'things' that are changing across WS and NS, by fold change. The fold change is calculated by the sum of the spectral counts attributed to each 'thing' - in eggNOG mapper and BLAST, the counts are aggregated by protein; in MEGAN, they are aggregated by eggNOG orthologous group; and in metaGOmics and Unipept, they are assigned to GO terms. In all cases, the Laplace correction is made, which is just adding 1 to all observed counts. This prevents division by zero, and allows for fold change estimation when one 'thing' was seen in one sample but not in another. 

# Reading in data
Necessary packages:
```{r message=FALSE}
library(GO.db)
library(data.table)
library(dplyr)
library(kableExtra)
library(stringr)
library(networkD3)
library(tidyverse)
library(reticulate)
```

## Directories
```{r}
tools_dir <- "data/tool_outputs/func_tools/"
```


## Peptides

These are the counts used in eggNOG-mapper and BLAST results interpretation. 

```{r}
peptidesNS <- read.delim("data/tool_outputs/peptide_shaker_outputs/737NS_Peptide_Shaker_Peptide_Report.tabular",
                         stringsAsFactors = FALSE) %>%
    select(peptide = Sequence, countNS = "X.Validated.PSMs")

peptidesWS <- read.delim("data/tool_outputs/peptide_shaker_outputs/737WS_Peptide_Shaker_Peptide_Report.tabular",
                         stringsAsFactors = FALSE) %>%
    select(peptide = Sequence, countWS = "X.Validated.PSMs") 

norm_ratio <- sum(peptidesWS$countWS) / sum(peptidesNS$countNS)
peptidesNS$countNS <- peptidesNS$countNS * sum(peptidesWS$countWS) / sum(peptidesNS$countNS)
peptides_all <- full_join(peptidesNS, peptidesWS, by = "peptide")
peptides_all[is.na(peptides_all)] <- 0
peptides_all
write.table(peptides_all$peptide, file="data/tool_outputs/peptide_shaker_outputs/peptides_all.txt",
            quote = FALSE, row.names = FALSE, col.names = FALSE)
```

## We need to expand and collapse to the GO-term level
```{r}
expand_by_go <- function(go_df, delimiter, header){
    # Separate the comma-delimited list of GOs into individual rows
    # (retains the fold change value from the original row)
    # go_df <- go_df %>% select(countNS, countWS, gos)
    go_df <- go_df %>% mutate(countNS = as.numeric(countNS),
                              countWS = as.numeric(countWS),
                              id = !!as.name(header))
    go_df <- data.table(go_df) 
    go_df <- go_df[ , list( gos = unlist( strsplit( gos , delimiter ) ) ) , by = list(id, log2ratio, countWS, countNS) ]
    go_df %>% mutate(name = Term(gsub(" ", "", gos)),
                     namespace = Ontology(gos))
    # Collapse GO terms based on fold change values.
    # go_df <- go_df %>% 
    #     group_by(gos) %>%
    #     select(countNS, countWS, gos) %>%
    #     summarize_all(sum) %>%
    #     mutate(name = Term(gsub(" ", "", gos)),
    #            log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    #     arrange(-log2ratio)
}

calculate_fold_change <- function(df){
  df %>% mutate(log2ratio = log2((as.numeric(countWS) + 1)/(as.numeric(countNS) + 1))) %>%
    arrange(-log2ratio)
}

# expand_go <- function(df){
#   df %>% mutate(name = Term(gsub(" ", "", gos)),
#                 namespace = Ontology(gos))
# }
```

## eggNOG mapper results

Join peptides to counts, and calculate ratios.

```{r}
eggnog <- read.delim("data/tool_outputs/func_tools/eggnogmap_results/diamond_annotations.tabular",
                     stringsAsFactors = FALSE,
                     header = FALSE) %>% 
    select(peptide = V1, protein = V2, gene = V5, gos = V6, ko = V7, desc = V13)
eggnog_w_counts <- left_join(eggnog,
                             peptides_all,
                             by = "peptide") %>%
    group_by(protein, desc, gene, gos) %>%
    summarize(countWS = sum(countWS), countNS = sum(countNS)) %>%
    select(protein, gos, gene, countWS, countNS, desc)
#eggnog_w_counts$gos <- filterOntology(eggnog_w_counts$gos, ontology)
#eggnog_w_counts$name <- sapply(strsplit(eggnog_w_counts$gos, ","), function ( x ) { paste(Term(x), collapse="; ")})

eggnog_w_counts <- calculate_fold_change(eggnog_w_counts)
eggnog_w_counts_gos <- expand_by_go(eggnog_w_counts, ',', 'protein')
eggnog_w_counts
eggnog_w_counts_gos
```

Let's write a function to write out formatted input tabular files for metaquantome.
```{r}
write_mqome_inputs <- function(df, name, header, col_gos, col_samp1, col_samp2) {
    int_df <- df[c(header, col_samp1, col_samp2)]
    names(int_df)[1] <- 'peptide'
    write.table(int_df,
                file=paste0("results/mqome/input/", name, "/", name, "_int.tab"),
                quote=FALSE, row.names=FALSE, sep="\t")
    func_df <- df[c(header, col_gos)]
    names(func_df)[1] <- 'peptide'
    write.table(func_df,
                file=paste0("results/mqome/input/", name, "/", name, "_func.tab"),
                quote=FALSE, row.names=FALSE, sep="\t")
}
write_mqome_inputs(eggnog_w_counts, 'eggnog', 'gos', 'gos', 'countNS', 'countWS')
```


Top *N*:
```{r echo=FALSE, results='asis'}
library(knitr)
n <- 10
kable(head(eggnog_w_counts, n), caption = paste("eggNOG-mapper: top", n, "fold changes"))
```


The <a href="http://pfam.xfam.org/family/PF05658">Pfam:YadA</a> refers to the YadA head domain in the trimeric autotransporter adhesin protein family. 

## Blast
```{r}
blast <- read.delim('data/tool_outputs/blast_results/blastp_vs_nr_current.tabular',
                   stringsAsFactors = FALSE,
                    header = FALSE) %>%
    select(peptide = V1, protein = V2, desc = V25)

blast_counts <- left_join(blast, peptides_all, by = "peptide") %>%
    group_by(protein, desc) %>%
    filter(!is.na(countWS) & !is.na(countNS)) %>%
    summarize(sumCountWS = sum(countWS) + 1, sumCountNS = sum(countNS) + 1) %>%
    mutate(log2ratio = log2(sumCountWS/sumCountNS)) %>%
    arrange(-log2ratio)
```

Print results:
```{r echo=FALSE, results='asis'}
kable(head(blast_counts, n), caption = paste("BLAST: Top ", n, " fold changes"))
```

## metaGOmics

Let's format the input for metagomics:
```{r}
write.table(peptidesWS, file="data/tool_inputs/metagomics/737WS_peptide_counts.tabular",
            row.names=FALSE, col.names=FALSE, quote=FALSE, sep="\t")
write.table(peptidesNS, file="data/tool_inputs/metagomics/737NS_peptide_counts.tabular",
            row.names=FALSE, col.names=FALSE, quote=FALSE, sep="\t")
```

The metagomics run is located here: https://www.yeastrc.org/metagomics/viewUploadedFasta.do?uid=ZgOKj9ROcCbJLdlw

We take the top *n* results that have a FDR-corrected $q$ value less than 0.05. 

```{r}
metagomics <- read.delim("data/tool_outputs/func_tools/metaGOmics_results/go_compare_149_150.txt",
                         comment.char = "#") %>%
    select(gos = GO.acc,
           name = GO.name,
           countNS = Run.1.PSM.count,
           countWS = Run.2.PSM.count,
           Laplace.corr..Log.2..fold.change,
           p = Laplace.corr..q.value)

metagomics_filt <- calculate_fold_change(metagomics) %>% 
  filter(p < 0.05)
metagomics_filt$namespace <- Ontology(as.character(metagomics_filt$go))
metagomics_filt
```

Top *n* results:
```{r echo=FALSE, results='asis'}
kable(head(metagomics_filt, n), caption = paste("MetaGOmics: Top", n, "fold changes"))
```

Metaquantome-normalized dataset:
```{r}
write_mqome_inputs(metagomics_filt, 'metagomics', 'gos', 'gos', 'countNS', 'countWS')
```

## MEGAN

```{r}
megan <- read.delim("data/tool_outputs/func_tools/MEGAN_outputs/737NSvsWS_EGGNOGcount.csv") %>%
    select(og = X.Datasets, 
           countWS = X737_WS_BLASTOutput_2StepCombined,
           countNS = X737_NS_BLASTOutput_2StepCombined)
megan_go <- read.delim("data/tool_outputs/func_tools/MEGAN_outputs/go_terms.txt",
                        header = TRUE,
                        stringsAsFactors = FALSE)
megan$gos <- megan_go$gos
#megan$countNS <- megan$countNS * norm_ratio

megan <- calculate_fold_change(megan)
megan_gos <- expand_by_go(megan, ',', 'og')
megan
megan_gos
# sum(megan$countWS)
# sum(megan$countNS)
# sum(megan$countWS) / sum(megan$countNS)
# norm_ratio
```

Top *n* results:
```{r echo=FALSE, results='asis'}
kable(head(megan, n), caption = paste("MEGAN: Top", n, "fold changes"))
```

Note that <a href="https://enzyme.expasy.org/EC/3.2.1.52">EC 3.2.1.52</a> is a beta-hexosaminidase and <a href="http://eggnogdb.embl.de/#/app/results?target_nogs=ENOG410YESU">ENOG410YESU</a> is involved in cell wall/membrane/envelope biogenesis.

Metaquantome-normalized dataset:
```{r}
write_mqome_inputs(megan, 'megan', 'gos', 'gos', 'countNS', 'countWS')
```

## Unipept

```{r}
unipept_results_NS <- paste0(tools_dir, 'unipept_results/',
                               list.files(paste0(tools_dir, 'unipept_results/'), pattern = "^737NS.*\\.csv"))
unipept_results_WS <- paste0(tools_dir, 'unipept_results/',
                               list.files(paste0(tools_dir, 'unipept_results/'), pattern = "^737WS.*\\.csv"))
unipeptNS <- lapply(unipept_results_NS, function(i) {
        read.delim(i, sep = ',', as.is = TRUE)}) %>%
    bind_rows() %>%
    select(-X) %>%
    rename(peptides = X.peptides)
unipeptNS$peptides = unipeptNS$peptides * norm_ratio
unipeptWS <- lapply(unipept_results_WS, function(i) {
    read.delim(i, sep = ',', as.is = TRUE)}) %>%
    bind_rows() %>%
    select(-X) %>%
    rename(peptides = X.peptides)

unipept_all <- inner_join(unipeptNS, unipeptWS, by = c("GO.term", "Name")) %>%
    mutate(countNS = peptides.x, countWS = peptides.y) %>%
    select(gos = GO.term, name = Name, countWS, countNS)
unipept_all <- calculate_fold_change(unipept_all)
unipept_all$namespace <- Ontology(unipept_all$gos)
unipept_all
# sum(unipeptWS$peptides)
# sum(unipeptNS$peptides) 
# sum(unipeptWS$peptides) / sum(unipeptNS$peptides)
```

Top *n*:
```{r echo=FALSE, results='asis'}
kable(head(unipept_all, n), caption = paste("Unipept: top", n, "Fold Changes"))
```

Metaquantome-normalized dataset:
```{r}
write_mqome_inputs(unipept_all, 'unipept', 'gos', 'gos', 'countNS', 'countWS')
```

## MetaProteomeAnalyzer

```{r}
ns_files <- list.files('data/tool_outputs/func_tools/mpa_results/NS', pattern = "_proteins.csv", full.names = TRUE)
pNS <- bind_rows(lapply(ns_files, function(i) read.delim(i, stringsAsFactors = FALSE))) %>%
    group_by(Protein.Accession, Protein.Description) %>%
    summarize("SpecCount" = sum(Spectral.Count))
ws_files <- list.files('data/tool_outputs/func_tools/mpa_results/WS', pattern = "_proteins.csv", full.names = TRUE)
pWS <- bind_rows(lapply(ws_files, function(i) read.delim(i, stringsAsFactors = FALSE))) %>%
    group_by(Protein.Accession, Protein.Description) %>%
    summarize("SpecCount" = sum(Spectral.Count))
pAll <- data.table(full_join(pNS, pWS, by=c("Protein.Accession", "Protein.Description"))) %>%
    rename(countNS = SpecCount.x, countWS = SpecCount.y, )

mpa_uniprot <- read.delim('data/tool_outputs/func_tools/mpa_results/uniprot_protein_results.tab', stringsAsFactors = FALSE)
pAll$gos <- as.character(sapply(pAll$Protein.Accession, function ( protid ) {
    goids <- mpa_uniprot[mpa_uniprot$Entry == protid,]$Gene.ontology.IDs
}))

# Normalization ratio
mpa_norm <- sum(pAll$countNS[!is.na(pAll$countNS)]) / sum(pAll$countWS[!is.na(pAll$countWS)])
pAll$countWS <- pAll$countWS * mpa_norm

pAll[is.na(pAll)] <- 0
pAll <- calculate_fold_change(pAll)

pAll_gos <- expand_by_go(pAll, "; ", 'Protein.Accession')
pAll
pAll_gos
# ns <- pAll$SpecCount.x
# ws <- pAll$SpecCount.y
# sum(ns[!is.na(ns)])
# sum(ws[!is.na(ws)])
# sum(ns[!is.na(ns)]) / sum(ws[!is.na(ws)])
```


Top *n*:
```{r echo=FALSE, results='asis'}
kable(head(pAll, n), caption = paste("MetaProteomeAnalyzer: top", n, "Fold Changes"))
```

Metaquantome-normalized dataset:
```{r}
write_mqome_inputs(pAll, 'mpa', 'gos', 'gos', 'countNS', 'countWS')
```


## Prophane
```{r}
prophane_WS <- read.delim(paste0(tools_dir, "prophane_results/summary_WS.txt"), sep = "\t",
                          stringsAsFactors = FALSE) %>% select(members_identifier,
                                                               ws = quant..sample_737..mean.,
                                                               ws_go1 = task_6..fun_from_TIGRFAMs_15_cut_tc..tigrfam2GO,
                                                               ws_go2 = task_7..fun_from_PFAMs_32..pfam2GO,
                                                               ws_go3 = task_8..fun_from_eggNog_4.5.1..og2GO)
prophane_NS <- read.delim(paste0(tools_dir, "prophane_results/summary_NS.txt"), sep = "\t",
                          stringsAsFactors = FALSE) %>% select(members_identifier,
                                                               ns = quant..sample_737..mean.,
                                                               ns_go1 = task_6..fun_from_TIGRFAMs_15_cut_tc..tigrfam2GO,
                                                               ns_go2 = task_7..fun_from_PFAMs_32..pfam2GO,
                                                               ns_go3 = task_8..fun_from_eggNog_4.5.1..og2GO)
prophane <- data.table(inner_join(prophane_NS, prophane_WS, by = c("members_identifier")) %>%
    filter(ns != "-", ws != "-") %>%
    mutate(gos = gsub(" ","", paste(ns_go1, ws_go1, ns_go2, ws_go2, ns_go3, ws_go3, sep=","))) %>%
    filter(gos != "") %>%
    select(id = members_identifier, countWS = ws, countNS = ns, gos, ns_go1, ws_go1, ns_go2, ws_go2, ns_go3, ws_go3))
prophane$gos <- sapply(strsplit(prophane$gos,","), function(terms) {
   paste(terms[terms != "-" & terms != ""], collapse = ",")
})

prophane <- calculate_fold_change(prophane)
prophane_gos <- expand_by_go(prophane, ',', 'id')
  #expand_by_go(prophane, ',') %>%
  #  mutate(log2ratio = log2(as.double(countWS)/as.double(countNS))) %>%
  #  arrange(-log2ratio)
#prophane$namespace <- Ontology(prophane$gos)
prophane
prophane_gos
```

Metaquantome-normalized dataset:
```{r}
write_mqome_inputs(prophane, 'prophane', 'gos', 'gos', 'countNS', 'countWS')
```


Let's expand and filter using metaquantome
```{r}
print_mqome_cmds <- function(name, func_colname){
  cmd_expand <- paste0("metaquantome expand --mode f --data_dir data/databases/gene_ontology/mqome",
                        " --int_file results/mqome/input/", name, "/", name, "_int.tab",
                       " --pep_colname_int peptide",
                       " --func_file results/mqome/input/", name, "/", name, "_func.tab",
                       " --pep_colname_func peptide",
                       " --func_colname ", func_colname," --ontology go",
                       " --samps results/mqome/input/samples.tab",
                       " --outfile results/mqome/output/", name, "/", name, "_func_expanded.tab")
  cmd_filt <- paste0("metaquantome filter",
                     " --expand_file results/mqome/output/", name, "/", name, "_func_expanded.tab",
                     " --mode f --ontology go",
                     " --samps results/mqome/input/samples.tab",
                     " --min_peptides 2 --min_pep_nsamp 0 --min_children_non_leaf 2 --min_child_nsamp 1",
                     " --qthreshold 0 --outfile results/mqome/output/", name, "/", name, "_func_filtered.tab")
  return(paste(cmd_expand, cmd_filt, sep='; '))
}
paste(print_mqome_cmds("eggnog", 'gos'),
      print_mqome_cmds("metagomics", "gos.1"),
      print_mqome_cmds("megan", "gos"),
      print_mqome_cmds("mpa", "gos"),
      print_mqome_cmds("prophane", "gos"),
      print_mqome_cmds("unipept", "gos.1"), sep='; ')
```

```{r}
eggnog_expanded <- read.delim("results/mqome/output/eggnog/eggnog_func_expanded.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
eggnog_filtered <- read.delim("results/mqome/output/eggnog/eggnog_func_filtered.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
unipept_expanded <- read.delim("results/mqome/output/unipept/unipept_func_expanded.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
unipept_filtered <- read.delim("results/mqome/output/unipept/unipept_func_filtered.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
metagomics_expanded <- read.delim("results/mqome/output/metagomics/metagomics_func_expanded.tab",
                             stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
metagomics_filtered <- read.delim("results/mqome/output/metagomics/metagomics_func_filtered.tab",
                             stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
mpa_expanded <- read.delim("results/mqome/output/mpa/mpa_func_expanded.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
mpa_filtered <- read.delim("results/mqome/output/mpa/mpa_func_filtered.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
prophane_expanded <- read.delim("results/mqome/output/prophane/prophane_func_expanded.tab",
                                stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
prophane_filtered <- read.delim("results/mqome/output/prophane/prophane_func_filtered.tab",
                                stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
megan_expanded <- read.delim("results/mqome/output/megan/megan_func_expanded.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
megan_filtered <- read.delim("results/mqome/output/megan/megan_func_filtered.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
```


```{r}
test <- megan_gos %>% filter(gos %in% megan_min_hits)
test <- test[!duplicated(test$gos),]
write_mqome_inputs(test, 'megan', 'gos', 'gos', 'countNS', 'countWS')
print_mqome_cmds("megan", "gos.1")
megan_expanded <- read.delim("results/mqome/output/megan/megan_func_expanded.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
megan_filtered <- read.delim("results/mqome/output/megan/megan_func_filtered.tab", stringsAsFactors = FALSE) %>%
    mutate(log2ratio = log2((countWS + 1)/(countNS + 1))) %>%
    arrange(-log2ratio)
```

```{r}
filter_to_nodes <- function(df){
  df[is.na(df['countWS_n_samp_children']) &
     is.na(df['countNS_n_samp_children']),]
}
filter_to_ancestors <-function(df){
  df[!is.na(df['countWS_n_samp_children']) &
     !is.na(df['countNS_n_samp_children']),]
}
```

```{r}
test
```

```{r}
filter_to_nodes(megan_expanded)
```


<!-- ```{r} -->
<!-- unipept_expanded[c('countNS_n_peptide', 'countWS_n_peptide', -->
<!--                    'countNS_n_samp_children', 'countWS_n_samp_children')] -->
<!-- ``` -->

<!-- ```{r} -->
<!-- unipept_expanded -->
<!-- ``` -->

<!-- filter_to_ancestors(unipept_filtered) -->
<!-- filter_to_nodes(unipept_filtered) -->
<!-- ``` -->


# ```{r}
# test <- unipept_all #%>% arrange(gos)
# test <- test[1:5,]
# #test <- unipept_all[grepl("(cytidylate kinase)|(1-phosphofructokinase)|(^kinase activity)", unipept_all$name),]
# write_mqome_inputs(test, 'unipept', 'gos', 'gos', 'countNS', 'countWS')
# print_mqome_cmds <- function(name, func_colname){
#   cmd_expand <- paste0("metaquantome expand --mode f --data_dir data/databases/gene_ontology/mqome",
#                         " --int_file results/mqome/input/", name, "/", name, "_int.tab",
#                        " --pep_colname_int peptide",
#                        " --func_file results/mqome/input/", name, "/", name, "_func.tab",
#                        " --pep_colname_func peptide",
#                        " --func_colname ", func_colname," --ontology go",
#                        " --samps results/mqome/input/samples.tab",
#                        " --outfile results/mqome/output/", name, "/", name, "_func_expanded.tab")
#   cmd_filt <- paste0("metaquantome filter",
#                      " --expand_file results/mqome/output/", name, "/", name, "_func_expanded.tab",
#                      " --mode f --ontology go",
#                      " --samps results/mqome/input/samples.tab",
#                      " --min_peptides 2 --min_pep_nsamp 0 --min_children_non_leaf 2 --min_child_nsamp 1",
#                      " --qthreshold 0 --outfile results/mqome/output/", name, "/", name, "_func_filtered.tab")
#   return(paste(cmd_expand, cmd_filt, sep='; '))
# }
# test
# print_mqome_cmds("metagomics", "gos.1")
# ```
# ```{r}
# unipept_all
# ```
# ```{r}
# unipept_all
# ```
# ```{r}
# prophane
# ```


# ```{r}
# unipept_expanded
# filter_to_nodes <- function(df){
#   df[df['countWS_n_samp_children'] == 0 &
#      df['countNS_n_samp_children'] == 0,]
# }
# filter_to_ancestors <-function(df){
#   df[df['countWS_n_samp_children'] != 0 &
#      df['countNS_n_samp_children'] != 0,]
# }
# filter_to_ancestors(unipept_filtered)
# ```

```{r}
filter_ontology_df <- function(tool, ontology){
  translations <- list("MF" = "molecular_function", "BP" = "biological_process", "CC" = "cellular_component")
  tool %>% filter(namespace %in% c(ontology, translations[ontology][[1]]))
}
ontology <- 'MF'
tools_gos <- list(filter_ontology_df(eggnog_w_counts_gos, ontology),
              filter_ontology_df(megan_gos, ontology),
              filter_ontology_df(metagomics_filt, ontology),
              filter_ontology_df(pAll_gos, ontology),
              filter_ontology_df(prophane_gos, ontology),
              filter_ontology_df(unipept_all, ontology))
```


### Let's do some single GO analysis

Let's find the GO set that is common in all tools:
```{r}
intersect_all_gos <- Reduce(intersect, sapply(tools_gos, function(tool) { tool[tool$namespace == "MF",]$gos }))
length(intersect_all_gos)
```

Let's find the term with the highest average percentile:
```{r}
average_ranks <- sapply(intersect_all_gos, function(go){
  mean(sapply(tools_gos, function(tool){ 
    which(tool$gos == go)[1]
  }))
})
highest_intersected_term <- average_ranks[average_ranks == min(average_ranks)]
highest_intersected_term
```
```{r}
character_lengths <- sapply(Term(intersect_all_gos), function(name) { 
  nchar(name) 
})
longest_character_term <- average_ranks[character_lengths == max(character_lengths)]
longest_character_term
```
```{r}
total_hits <- sapply(intersect_all_gos, function(go){
  sum(sapply(tools_gos, function(tool){ 
    hits = tool$gos == go
    length(hits[hits == TRUE])
  }))
})
 
sapply(tools_gos, function(tool){
    hits = tool$gos == 'GO:0004854'
    length(hits[hits == TRUE])
})
min(total_hits)
small_hits_go <- average_ranks[total_hits == min(total_hits)]
small_hits_go <- 'GO:0004854'
small_hits_go
```


Let's find the term with the most ancestors:
```{r}
library(httr)
library(jsonlite)
get_go_ancestors <- function(id_vector){
    base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/'
    terms <- str_replace(id_vector, ":", "%3A")
    joined_terms <- paste(terms, collapse="%2C")
    term_url <- paste(base_url, joined_terms, '/ancestors?relations=is_a', sep="")
    term_info <- GET(term_url, accept("application/json"))
    json <- toJSON(content(term_info))
    names <- unlist(fromJSON(json)$results$ancestors)
    names
}
go_num_ancestors <- sapply(intersect_all_gos, function(go){ length(get_go_ancestors(go)) })
go_num_ancestors[go_num_ancestors == max(go_num_ancestors)]
go_most_ancestors <- 'GO:0046933'
```


With this term chosen (fewest number of hits), let's examine it in depth.

### Single GO Term Analysis

#### Chosen GO term

```{r}
go_target <- small_hits_go
# go_target <- go_most_ancestors
Term(go_target)
```

```{r}
get_go_rows <- function(go, tool) {tool[grepl(go, tool$gos),] }
filterOntology <- function(gos, ontology){
 gos_filt <- gos[Ontology(gos) == ontology] 
 gos_filt[!is.na(gos_filt)]
}
split_gos <- function(go_list, delimiter=','){ strsplit(go_list, delimiter)[[1]]}
```


```{r}
rows <- get_go_rows(go_target, eggnog_w_counts)
eggnog_min_hits <- filterOntology(split_gos(rows$gos), 'MF')
rows
paste(eggnog_min_hits, collapse=" ")
```

```{r}
rows <- get_go_rows(go_target, megan)
megan_min_hits <- unique(filterOntology(split_gos(rows$gos), 'MF'))
rows
paste(megan_min_hits, collapse=" ")
```

```{r}
length(eggnog_min_hits)
length(intersect(eggnog_min_hits, megan_min_hits))
length(megan_min_hits)
length(intersect(megan_min_hits, prophane_min_hits))
length(prophane_min_hits)
length(intersect(megan_min_hits, unipept_pep_gos_mf))
length(unipept_pep_gos_mf)
length(intersect(mpa_min_hits, unipept_pep_gos_mf))
length(mpa_min_hits)
```
```{r}
paste(unipept_pep_gos_mf, collapse = " ")
```


Metagomics
```{r}
rows <- get_go_rows(min_hits_go, metagomics_filt)
metagomics_min_hits <- filterOntology(split_gos(rows$gos), 'MF')
rows
metagomics_min_hits
```

MetaProteomeAnalyzer
```{r}
rows <- get_go_rows(go_target, pAll)
mpa_min_hits <- filterOntology(split_gos(unique(rows$gos), delimiter="; "), 'MF')
rows
paste(mpa_min_hits, collapse=' ')
```

Prophane
```{r}
rows <- get_go_rows(go_target, prophane)
prophane_min_hits <- unique(filterOntology(split_gos(unique(rows$gos)), 'MF'))
rows
paste(prophane_min_hits, collapse=" ")
```

#### Unipept Peptides
```{r}
add_coverage <- function(gos_col, go_protein_counts_col, total_protein_count_col){
  mapply(function(gos_col, go_protein_counts_col, total_protein_count_col){
    sapply(1:length(gos_col), function(i){
      gos_list <- strsplit(as.character(gos_col[i]), ',')[[1]]
      gos_protein_counts_list <- strsplit(as.character(go_protein_counts_col[i]), ',')[[1]]
      paste(mapply(function(gos, go_protein_counts) {
        coverage <- round(as.numeric(go_protein_counts) / total_protein_count_col[i], digits = 3)
        paste0(gos, '(', coverage, ')')
      }, gos=gos_list, go_protein_counts=gos_protein_counts_list),
      collapse=",")
    })
  }, gos_col=gos_col, go_protein_counts_col=go_protein_counts_col, total_protein_count_col)
}

filter_coverages <- function(go_lists){
  sapply(go_lists, function(go_list){
    go_list <- strsplit(go_list, ',')[[1]]
    #go_list
    coverages <- as.numeric(str_match(go_list, '\\((.+)\\)')[,2])
    paste(go_list[coverages > 0.05], collapse=',')
  })
} 

filter_go_mf <- function(go_list){
  go_list <- strsplit(as.character(go_list), ',')[[1]] 
  go_processed <- sapply(go_list, function(go){
    str_match(go, '(GO:\\d+)\\((.+)\\)')
  })
  go_processed[2,][Ontology(go_processed[2,]) == "MF"]
}

unipept_pep <- read.delim('data/tool_outputs/func_tools/unipept_results/737ALL_Galaxy3-[Unipept_pept2go_on_data_1_tsv].tabular') %>%
  filter(str_detect(go_terms, go_target)) %>%
  mutate(go_coverage = add_coverage(go_terms, go_protein_counts, total_protein_count),
         filtered_gos = filter_coverages(go_coverage),
         go_mf_filtered = sapply(filtered_gos, function(go_list){
           paste(filter_go_mf(go_list), collapse=',')
         }))
unipept_pep

unipept_pep_refiltered <- unipept_pep %>%
  filter(str_detect(go_mf_filtered, go_target))
unipept_pep_gos_mf <- unique(unipept_pep_refiltered$go_mf_filtered)
unipept_pep_gos_mf <- unique(unlist(strsplit(unipept_pep_gos_mf, ',')))
unipept_pep_gos_mf
```


Export out 'arginine binding' peptides from Unipept for Metagomics:
```{r}
write.table(unipept_pep$X.peptide, file=paste0(tools_dir, 'unipept_results/arginine_binding_peptides.txt'),
            row.names=FALSE, col.names=FALSE, quote=FALSE)
write.table(paste0(unipept_pep$X.peptide, "\t1"), file=paste0('data/tool_inputs/metagomics/arginine_binding_peptides.txt'),
            row.names=FALSE, col.names=FALSE, quote=FALSE)
```

```{r}
get_go_rows(min_hits_go, megan)
```

```{r}
eggnog %>% filter(peptide %in% unipept_pep$X.peptide)
```


## Unipept and MetaGOmics

This is comparing the estimated fold changes for GO terms for the two tools that natively use GO terms, Unipept and MetaGOmics. 

## Function for filtering ontologies

```{r}
plot_correlation <- function(unipept, metagomics, header, dims, ontology, suffix=''){
  if (ontology != 'all'){
    unipept <- filterOntology(unipept, ontology)
    metagomics <- filterOntology(metagomics, ontology)
  }
  if (nrow(unipept)){
    um <- inner_join(unipept, metagomics, by = header)
    png(paste0("results/correlation/um_cor", paste(suffix, ontology, sep='-'), ".png"),
        res = 700, width = 3.5, height = 4, units = "in")
    plot(log2ratio.x ~ log2ratio.y, data = um, pch = 20, cex = 0.3, xlim=dims, ylim=dims,
         xlab = "Unipept: Log2 Ratio",
         ylab = "MetaGOmics: Log2 Ratio")
    mod <- lm(log2ratio.x ~ log2ratio.y, data = um)
    abline(0, 1, col = "red", lty = 2)
    abline(coef(mod))
    grid()
    dev.off()
    results <- cor.test(um$log2ratio.x, um$log2ratio.y,
             method = "pearson", alternative = "two.sided")
    print(paste0(ontology, suffix))
    print(nrow(um))
    print(nrow(unipept))
    print(nrow(metagomics))
    print(results)
    results
  }
}

results <- sapply(c("MF", "CC", "BP", "all"),
                  function(ontology){
                    list(plot_correlation(unipept_all, metagomics_filt,
                                          'gos', c(-8, 8), ontology),
                         plot_correlation(unipept_filtered, metagomics_filtered, 
                                          'id', c(-1.5, 1.5), ontology, suffix='-filtered'))
                  })

```

### Rank comparison

How do metaGOmics and Unipept rankings compare? 

```{r}
top5_meta <- metagomics_filt$go[1:5]
m2u_ranks <- rep(0, 5)
u2m_ranks <- rep(0, 5)
top5_uni <- unipept_all$GO.term[1:5]
for (i in 1:5){
    m2u_rank <- which(unipept_all$GO.term == top5_meta[i])
    u2m_rank <- which(metagomics_filt$go == top5_uni[i])
    m2u_ranks[i] <- ifelse(length(m2u_rank) == 1, m2u_rank, NA)
    u2m_ranks[i] <- ifelse(length(u2m_rank) == 1, u2m_rank, NA)
}
# 
# m2u <- data.frame("go_term" = top5_meta,
#                   "rank_in_metagomics" = 1:5,
#                   "rank_in_unipept" = m2u_ranks)
# 
# u2m <- data.frame("go_term" = top5_uni,
#                   "rank_in_unipept" = 1:5,
#                   "rank_in_metagomics" = u2m_ranks)

```

### How Unipept Ranks MetaGOmics' top 5
```{r echo=FALSE, results='asis'}
kable(m2u)
```

### How MetaGOmics ranks Unipept's top 5
```{r echo=FALSE, results='asis'}
kable(u2m)
```

### Top Ten Tables
```{r}
get_rank_table <- function(name, tools, folder){
    n <- 10
    if (name == "Unipept"){
        n <- 15
    }
    labels <- c("EggNOG", "MEGAN", "MetaGOmics", "MPA", "Prophane", "Unipept")
    tool_topn <- tools[which(labels == name)][[1]]$name[1:n]
    rank_table <- data.frame(names = unlist(lapply(tool_topn, function(a) { c(as.character(a), '')})))
    rank_table[,"Ranking"] <- rep(c('FC (WS / NS)', 'Percentile (%)'), n)
    for (i in 1:length(tools)){
        output <- sapply(tool_topn, function(topn){
            tool <- tools[i][[1]]
            rank <- which(grepl(topn, tool$name, fixed=TRUE))
            if (length(rank) > 0){
                term <- tool[rank[[1]],]
                list(paste(ifelse(is.null(term$countWS) && is.null(term$countNS),
                                       paste0('(', round(as.numeric(term$log2ratio), digits=2), ')'),
                                       paste0(round(as.numeric(term$log2ratio), digits=2),
                                              ' (', round(as.numeric(term$countWS), digits=2), ' / ',
                                                    round(as.numeric(term$countNS), digits=2), ')'))),
                     round(as.numeric(rank[[1]] / nrow(tool) * 100), digits=3))
            } else {
                list('-','-')
            }
        })
        rank_table[,labels[i]] <- unlist(output)
    }
    rank_table <- rank_table %>% select('GO Term' = names, "Ranking", name, everything())
    write.table(rank_table,
                file=paste0("results/rank_tables/", folder, "/", name, "-rank_table.tabular"),
                sep='\t', quote=FALSE, row.names=FALSE)
}

# tool_topn
remove_blanks <- function(go_list){
    go_list[go_list$name != "",]
}

# filterOntology <- function(go_list, ontology){
#   if (ontology == "all") { return(go_df) }
#   sapply(go_list, function (go_cell) {
#     go_list <- strsplit(toString(go_cell), ",")[[1]]
#     onts <- Ontology(go_list)
#     filtered_gos <- go_list[onts == ontology & !is.na(onts) & onts != ""]
#     return(paste(filtered_gos, collapse = ","))
#     })
# }

ontology <- 'MF'
tools <- list(filter_ontology_df(eggnog_w_counts, ontology),
              filter_ontology_df(megan, ontology),
              filter_ontology_df(metagomics_filt, ontology),
              filter_ontology_df(pAll, ontology),
              filter_ontology_df(prophane, ontology),
              filter_ontology_df(unipept_all, ontology))
get_rank_table("Unipept", tools, 'full')
get_rank_table("EggNOG", tools, 'full')
get_rank_table("MEGAN", tools, 'full')
get_rank_table("MetaGOmics", tools, 'full')
get_rank_table("MPA", tools, 'full')
get_rank_table("Prophane", tools, 'full')

tools <- list(filter_ontology_df(eggnog_filtered, ontology),
              filter_ontology_df(megan_filtered, ontology),
              filter_ontology_df(metagomics_filtered, ontology),
              filter_ontology_df(mpa_filtered, ontology),
              filter_ontology_df(prophane_filtered, ontology),
              filter_ontology_df(unipept_filtered, ontology))
get_rank_table("Unipept", tools, 'filtered')
get_rank_table("EggNOG", tools, 'filtered')
get_rank_table("MEGAN", tools, 'filtered')
get_rank_table("MetaGOmics", tools, 'filtered')
get_rank_table("MPA", tools, 'filtered')
#get_rank_table("Prophane", tools, 'filtered')
```
```{r}
megan
```


### GO list exporting
```{r}
labels <- c("EggNOG", "MEGAN", "MetaGOmics", "MPA", "Prophane", "Unipept")
tools <- list(eggnog_w_counts, megan, metagomics_filt, pAll, prophane, unipept_all)
tools_mqome <- list(eggnog_filtered, megan_filtered, metagomics_filtered,
                      mpa_filtered, prophane_filtered, unipept_filtered)
for (i in 1:length(tools)){
  write.table(tools[i], file=paste0('results/go_output/full/', tolower(labels[i]), '.tabular'),
              row.names=FALSE, quote=FALSE)
  write.table(tools[[i]]$gos, file=paste0('results/go_output/go_only/full/',
                                          tolower(labels[i]), '.tabular'),
              row.names=FALSE, col.names=FALSE, quote=FALSE)
  write.table(tools[[i]]$gos, file=paste0('results/go_output/go_only/filtered/',
                                          tolower(labels[i]), '.tabular'),
              row.names=FALSE, col.names=FALSE, quote=FALSE)
  write.table(filterOntology(tools[[i]], "MF")$gos, file=paste0('results/go_output/go_only/MF/',
                                          tolower(labels[i]), '.tabular'),
              row.names=FALSE, col.names=FALSE, quote=FALSE)
  
}
```

### Overlap Plot Generation
```{r}
library(reshape2)
library(ggplot2)

generate_overlap_plot <- function(ontology){
  
  
  labels <- c("EggNOG", "MEGAN", "MetaGOmics", "MPA", "Prophane", "Unipept")
  tools_mqome <- list(eggnog_filtered, megan_filtered, metagomics_filtered,
                      mpa_filtered, prophane_filtered, unipept_filtered)
  filtered_tools <- function(tools, ontology){
    translations <- list("MF" = "molecular_function",
                         "BP" = "biological_process",
                         "CC" = "cellular_component")
    lapply(tools, function( tool ) { tool %>% filter(namespace %in% c(ontology, translations[ontology][[1]]))})
  }
  gos <- sapply(filtered_tools(tools, ontology), function(tool){ tool$gos})
  
  jaccard <- function(vec1, vec2){
    c1 <- length(vec1)
    c2 <- length(vec2)
    int <- length(intersect(vec1, vec2))
    int / c1
  }
  
  jacmat <- matrix(0, nrow = 6, ncol = 6)
  for (i in 1:6){
    for (j in 1:6){
      jacmat[i, j] <- jaccard(unique(gos[[i]]), unique(gos[[j]]))
    }
  }
  dimnames(jacmat) <- list(labels, labels)
  
  # gos_filt <- list('eggnog' = unique(filterOntology(eggnog_filtered$id, ontology)),
  #         'megan' = unique(filterOntology(megan_filtered$id, ontology)),
  #         'metagomics' = unique(filterOntology(metagomics_filtered$id, ontology)),
  #         'mpa' = unique(filterOntology(mpa_filtered$id, ontology)),
  #         'prophane' = unique(filterOntology(prophane_filtered$id, ontology)),
  #         'unipept' = unique(filterOntology(unipept_filtered$id, ontology)))
  
  gos_filt <- sapply(filtered_tools(tools_mqome, ontology), function(tool){ tool$id })
  
  
  jacslim <- matrix(0, nrow = 6, ncol = 6)
  for (i in 1:6){
    for (j in 1:6){
      jacslim[i, j] <- jaccard(unique(gos_filt[[i]]),
                               unique(gos_filt[[j]]))
    }
  }
  dimnames(jacslim) <- list(labels, labels)
  
  jac_melt <- melt(jacmat)
  jac_melt$method <- "Full GO"
  
  jac_melt_slim <- melt(jacslim)
  jac_melt_slim$method <- "Metaquantome-Filtered GO"
  
  jac_melt_all <- rbind(jac_melt, jac_melt_slim)
  
  ggplot(jac_melt_all)+
    geom_tile(aes(x = Var1, y = Var2, fill = value), color = "black") +
    geom_text(aes(x = Var1, y = Var2, label = format(value, digits = 2))) + 
    scale_fill_gradient(name="", low = "white", high = "dodgerblue", limits = c(0, 1),
                        guide = guide_colorbar(frame.colour = "black", ticks.colour = "black")) +
    facet_grid(.~method) +
    theme_minimal(base_size = 14) +
    theme(aspect.ratio = 1, axis.text.x = element_text(angle = 90)) +
    labs(x = NULL, y = NULL)
  ggsave(paste0("results/overlap_plots/overlap-", paste(ontology, collapse="-"), "-filtered.png"),
         height = 5, width = 12, units = "in", dpi = 700)
}

generate_overlap_plot(c("MF", "BP", "CC"))
generate_overlap_plot("MF")
generate_overlap_plot("BP")
generate_overlap_plot("CC")
```